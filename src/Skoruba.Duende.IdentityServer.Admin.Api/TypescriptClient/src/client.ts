//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.3.0.0 (NJsonSchema v11.2.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class WebApiClientBase {
    protected async transformOptions(options: RequestInit): Promise<RequestInit> {
        const headers = new Headers(options.headers);
        headers.set("X-CSRF", "1");

        return {
            ...options,
            headers,
        };
    }
}

export interface IApiResourcesClient {

    get(searchText: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<ApiResourcesApiDto>;

    post(apiResourceApi: ApiResourceApiDto): Promise<void>;

    put(apiResourceApi: ApiResourceApiDto): Promise<void>;

    canInsertApiResource(id: number | undefined, name: string | null | undefined): Promise<boolean>;

    canInsertApiResourceProperty(id: number | undefined, key: string | null | undefined): Promise<boolean>;

    get2(id: number): Promise<ApiResourceApiDto>;

    delete(id: number): Promise<void>;

    getSecrets(id: number, page: number | undefined, pageSize: number | undefined): Promise<ApiSecretsApiDto>;

    postSecret(id: number, clientSecretApi: ApiSecretApiDto): Promise<ApiSecretApiDto>;

    getSecret(secretId: number): Promise<ApiSecretApiDto>;

    deleteSecret(secretId: number): Promise<void>;

    getProperties(id: number, page: number | undefined, pageSize: number | undefined): Promise<ApiResourcePropertiesApiDto>;

    postProperty(id: number, apiPropertyApi: ApiResourcePropertyApiDto): Promise<ApiResourcePropertyApiDto>;

    getProperty(propertyId: number): Promise<ApiResourcePropertyApiDto>;

    deleteProperty(propertyId: number): Promise<void>;
}

export class ApiResourcesClient extends WebApiClientBase implements IApiResourcesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    get(searchText: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<ApiResourcesApiDto> {
        let url_ = this.baseUrl + "/api/ApiResources?";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ApiResourcesApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResourcesApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResourcesApiDto>(null as any);
    }

    post(apiResourceApi: ApiResourceApiDto): Promise<void> {
        let url_ = this.baseUrl + "/api/ApiResources";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(apiResourceApi);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    put(apiResourceApi: ApiResourceApiDto): Promise<void> {
        let url_ = this.baseUrl + "/api/ApiResources";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(apiResourceApi);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    canInsertApiResource(id: number | undefined, name: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/ApiResources/CanInsertApiResource?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCanInsertApiResource(_response);
        });
    }

    protected processCanInsertApiResource(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    canInsertApiResourceProperty(id: number | undefined, key: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/ApiResources/CanInsertApiResourceProperty?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (key !== undefined && key !== null)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCanInsertApiResourceProperty(_response);
        });
    }

    protected processCanInsertApiResourceProperty(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    get2(id: number): Promise<ApiResourceApiDto> {
        let url_ = this.baseUrl + "/api/ApiResources/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet2(_response);
        });
    }

    protected processGet2(response: Response): Promise<ApiResourceApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResourceApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResourceApiDto>(null as any);
    }

    delete(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/ApiResources/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getSecrets(id: number, page: number | undefined, pageSize: number | undefined): Promise<ApiSecretsApiDto> {
        let url_ = this.baseUrl + "/api/ApiResources/{id}/Secrets?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetSecrets(_response);
        });
    }

    protected processGetSecrets(response: Response): Promise<ApiSecretsApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiSecretsApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiSecretsApiDto>(null as any);
    }

    postSecret(id: number, clientSecretApi: ApiSecretApiDto): Promise<ApiSecretApiDto> {
        let url_ = this.baseUrl + "/api/ApiResources/{id}/Secrets";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(clientSecretApi);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostSecret(_response);
        });
    }

    protected processPostSecret(response: Response): Promise<ApiSecretApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ApiSecretApiDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiSecretApiDto>(null as any);
    }

    getSecret(secretId: number): Promise<ApiSecretApiDto> {
        let url_ = this.baseUrl + "/api/ApiResources/Secrets/{secretId}";
        if (secretId === undefined || secretId === null)
            throw new Error("The parameter 'secretId' must be defined.");
        url_ = url_.replace("{secretId}", encodeURIComponent("" + secretId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetSecret(_response);
        });
    }

    protected processGetSecret(response: Response): Promise<ApiSecretApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiSecretApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiSecretApiDto>(null as any);
    }

    deleteSecret(secretId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/ApiResources/Secrets/{secretId}";
        if (secretId === undefined || secretId === null)
            throw new Error("The parameter 'secretId' must be defined.");
        url_ = url_.replace("{secretId}", encodeURIComponent("" + secretId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteSecret(_response);
        });
    }

    protected processDeleteSecret(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getProperties(id: number, page: number | undefined, pageSize: number | undefined): Promise<ApiResourcePropertiesApiDto> {
        let url_ = this.baseUrl + "/api/ApiResources/{id}/Properties?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProperties(_response);
        });
    }

    protected processGetProperties(response: Response): Promise<ApiResourcePropertiesApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResourcePropertiesApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResourcePropertiesApiDto>(null as any);
    }

    postProperty(id: number, apiPropertyApi: ApiResourcePropertyApiDto): Promise<ApiResourcePropertyApiDto> {
        let url_ = this.baseUrl + "/api/ApiResources/{id}/Properties";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(apiPropertyApi);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostProperty(_response);
        });
    }

    protected processPostProperty(response: Response): Promise<ApiResourcePropertyApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ApiResourcePropertyApiDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResourcePropertyApiDto>(null as any);
    }

    getProperty(propertyId: number): Promise<ApiResourcePropertyApiDto> {
        let url_ = this.baseUrl + "/api/ApiResources/Properties/{propertyId}";
        if (propertyId === undefined || propertyId === null)
            throw new Error("The parameter 'propertyId' must be defined.");
        url_ = url_.replace("{propertyId}", encodeURIComponent("" + propertyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProperty(_response);
        });
    }

    protected processGetProperty(response: Response): Promise<ApiResourcePropertyApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResourcePropertyApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiResourcePropertyApiDto>(null as any);
    }

    deleteProperty(propertyId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/ApiResources/Properties/{propertyId}";
        if (propertyId === undefined || propertyId === null)
            throw new Error("The parameter 'propertyId' must be defined.");
        url_ = url_.replace("{propertyId}", encodeURIComponent("" + propertyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteProperty(_response);
        });
    }

    protected processDeleteProperty(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IApiScopesClient {

    getScopes(search: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<ApiScopesApiDto>;

    postScope(apiScopeApi: ApiScopeApiDto): Promise<ApiScopeDto>;

    putScope(apiScopeApi: ApiScopeApiDto): Promise<void>;

    canInsertApiScope(id: number | undefined, name: string | null | undefined): Promise<boolean>;

    canInsertApiScopeProperty(id: number | undefined, key: string | null | undefined): Promise<boolean>;

    getScope(id: number): Promise<ApiScopeApiDto>;

    deleteScope(id: number): Promise<void>;

    getScopeProperties(id: number, page: number | undefined, pageSize: number | undefined): Promise<ApiScopePropertiesApiDto>;

    postProperty(id: number, apiScopePropertyApi: ApiScopePropertyApiDto): Promise<ApiScopePropertyApiDto>;

    getProperty(propertyId: number): Promise<ApiScopePropertyApiDto>;

    deleteProperty(propertyId: number): Promise<void>;
}

export class ApiScopesClient extends WebApiClientBase implements IApiScopesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getScopes(search: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<ApiScopesApiDto> {
        let url_ = this.baseUrl + "/api/ApiScopes?";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetScopes(_response);
        });
    }

    protected processGetScopes(response: Response): Promise<ApiScopesApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiScopesApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiScopesApiDto>(null as any);
    }

    postScope(apiScopeApi: ApiScopeApiDto): Promise<ApiScopeDto> {
        let url_ = this.baseUrl + "/api/ApiScopes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(apiScopeApi);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostScope(_response);
        });
    }

    protected processPostScope(response: Response): Promise<ApiScopeDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ApiScopeDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiScopeDto>(null as any);
    }

    putScope(apiScopeApi: ApiScopeApiDto): Promise<void> {
        let url_ = this.baseUrl + "/api/ApiScopes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(apiScopeApi);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPutScope(_response);
        });
    }

    protected processPutScope(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    canInsertApiScope(id: number | undefined, name: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/ApiScopes/CanInsertApiScope?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCanInsertApiScope(_response);
        });
    }

    protected processCanInsertApiScope(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    canInsertApiScopeProperty(id: number | undefined, key: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/ApiScopes/CanInsertApiScopeProperty?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (key !== undefined && key !== null)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCanInsertApiScopeProperty(_response);
        });
    }

    protected processCanInsertApiScopeProperty(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    getScope(id: number): Promise<ApiScopeApiDto> {
        let url_ = this.baseUrl + "/api/ApiScopes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetScope(_response);
        });
    }

    protected processGetScope(response: Response): Promise<ApiScopeApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiScopeApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiScopeApiDto>(null as any);
    }

    deleteScope(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/ApiScopes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteScope(_response);
        });
    }

    protected processDeleteScope(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getScopeProperties(id: number, page: number | undefined, pageSize: number | undefined): Promise<ApiScopePropertiesApiDto> {
        let url_ = this.baseUrl + "/api/ApiScopes/{id}/Properties?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetScopeProperties(_response);
        });
    }

    protected processGetScopeProperties(response: Response): Promise<ApiScopePropertiesApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiScopePropertiesApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiScopePropertiesApiDto>(null as any);
    }

    postProperty(id: number, apiScopePropertyApi: ApiScopePropertyApiDto): Promise<ApiScopePropertyApiDto> {
        let url_ = this.baseUrl + "/api/ApiScopes/{id}/Properties";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(apiScopePropertyApi);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostProperty(_response);
        });
    }

    protected processPostProperty(response: Response): Promise<ApiScopePropertyApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ApiScopePropertyApiDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiScopePropertyApiDto>(null as any);
    }

    getProperty(propertyId: number): Promise<ApiScopePropertyApiDto> {
        let url_ = this.baseUrl + "/api/ApiScopes/Properties/{propertyId}";
        if (propertyId === undefined || propertyId === null)
            throw new Error("The parameter 'propertyId' must be defined.");
        url_ = url_.replace("{propertyId}", encodeURIComponent("" + propertyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProperty(_response);
        });
    }

    protected processGetProperty(response: Response): Promise<ApiScopePropertyApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiScopePropertyApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiScopePropertyApiDto>(null as any);
    }

    deleteProperty(propertyId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/ApiScopes/Properties/{propertyId}";
        if (propertyId === undefined || propertyId === null)
            throw new Error("The parameter 'propertyId' must be defined.");
        url_ = url_.replace("{propertyId}", encodeURIComponent("" + propertyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteProperty(_response);
        });
    }

    protected processDeleteProperty(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IClientsClient {

    get(searchText: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<ClientsApiDto>;

    post(client: ClientApiDto): Promise<ClientApiDto>;

    put(client: ClientApiDto): Promise<void>;

    get2(id: number): Promise<ClientApiDto>;

    delete(id: number): Promise<void>;

    getAccessTokenTypes(): Promise<SelectItemDto[]>;

    getTokenExpirations(): Promise<SelectItemDto[]>;

    getTokenUsage(): Promise<SelectItemDto[]>;

    getProtocolTypes(): Promise<SelectItemDto[]>;

    getDPoPValidationModes(): Promise<SelectItemDto[]>;

    getScopes(scope: string | null | undefined, limit: number | undefined, excludeIdentityResources: boolean | undefined, excludeApiScopes: boolean | undefined): Promise<string[]>;

    getGrantTypes(grant: string | null | undefined, includeObsoleteGrants: boolean | undefined, limit: number | undefined): Promise<SelectItemDto[]>;

    getHashTypes(): Promise<SelectItemDto[]>;

    getSecretTypes(): Promise<SelectItemDto[]>;

    getStandardClaims(claim: string | null | undefined, limit: number | undefined): Promise<string[]>;

    getSigningAlgorithms(algorithm: string | null | undefined, limit: number | undefined): Promise<string[]>;

    canInsertClient(id: number | undefined, clientId: string | null | undefined, isCloned: boolean | undefined): Promise<boolean>;

    postClientClone(client: ClientCloneApiDto): Promise<ClientApiDto>;

    getSecrets(id: number, page: number | undefined, pageSize: number | undefined): Promise<ClientSecretsApiDto>;

    postSecret(id: number, clientSecretApi: ClientSecretApiDto): Promise<ClientSecretApiDto>;

    getSecret(secretId: number): Promise<ClientSecretApiDto>;

    deleteSecret(secretId: number): Promise<void>;

    getProperties(id: number, page: number | undefined, pageSize: number | undefined): Promise<ClientPropertiesApiDto>;

    postProperty(id: number, clientPropertyApi: ClientPropertyApiDto): Promise<ClientPropertyApiDto>;

    getProperty(propertyId: number): Promise<ClientPropertyApiDto>;

    deleteProperty(propertyId: number): Promise<void>;

    getClaims(id: number, page: number | undefined, pageSize: number | undefined): Promise<ClientClaimsApiDto>;

    postClaim(id: number, clientClaimApiDto: ClientClaimApiDto): Promise<ClientClaimApiDto>;

    getClaim(claimId: number): Promise<ClientClaimApiDto>;

    deleteClaim(claimId: number): Promise<FileResponse>;
}

export class ClientsClient extends WebApiClientBase implements IClientsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    get(searchText: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<ClientsApiDto> {
        let url_ = this.baseUrl + "/api/Clients?";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ClientsApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientsApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientsApiDto>(null as any);
    }

    post(client: ClientApiDto): Promise<ClientApiDto> {
        let url_ = this.baseUrl + "/api/Clients";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(client);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<ClientApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ClientApiDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientApiDto>(null as any);
    }

    put(client: ClientApiDto): Promise<void> {
        let url_ = this.baseUrl + "/api/Clients";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(client);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    get2(id: number): Promise<ClientApiDto> {
        let url_ = this.baseUrl + "/api/Clients/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet2(_response);
        });
    }

    protected processGet2(response: Response): Promise<ClientApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientApiDto>(null as any);
    }

    delete(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Clients/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getAccessTokenTypes(): Promise<SelectItemDto[]> {
        let url_ = this.baseUrl + "/api/Clients/GetAccessTokenTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAccessTokenTypes(_response);
        });
    }

    protected processGetAccessTokenTypes(response: Response): Promise<SelectItemDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SelectItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SelectItemDto[]>(null as any);
    }

    getTokenExpirations(): Promise<SelectItemDto[]> {
        let url_ = this.baseUrl + "/api/Clients/GetTokenExpirations";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetTokenExpirations(_response);
        });
    }

    protected processGetTokenExpirations(response: Response): Promise<SelectItemDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SelectItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SelectItemDto[]>(null as any);
    }

    getTokenUsage(): Promise<SelectItemDto[]> {
        let url_ = this.baseUrl + "/api/Clients/GetTokenUsage";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetTokenUsage(_response);
        });
    }

    protected processGetTokenUsage(response: Response): Promise<SelectItemDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SelectItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SelectItemDto[]>(null as any);
    }

    getProtocolTypes(): Promise<SelectItemDto[]> {
        let url_ = this.baseUrl + "/api/Clients/GetProtocolTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProtocolTypes(_response);
        });
    }

    protected processGetProtocolTypes(response: Response): Promise<SelectItemDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SelectItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SelectItemDto[]>(null as any);
    }

    getDPoPValidationModes(): Promise<SelectItemDto[]> {
        let url_ = this.baseUrl + "/api/Clients/GetDPoPValidationModes";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetDPoPValidationModes(_response);
        });
    }

    protected processGetDPoPValidationModes(response: Response): Promise<SelectItemDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SelectItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SelectItemDto[]>(null as any);
    }

    getScopes(scope: string | null | undefined, limit: number | undefined, excludeIdentityResources: boolean | undefined, excludeApiScopes: boolean | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/Clients/GetScopes?";
        if (scope !== undefined && scope !== null)
            url_ += "scope=" + encodeURIComponent("" + scope) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (excludeIdentityResources === null)
            throw new Error("The parameter 'excludeIdentityResources' cannot be null.");
        else if (excludeIdentityResources !== undefined)
            url_ += "excludeIdentityResources=" + encodeURIComponent("" + excludeIdentityResources) + "&";
        if (excludeApiScopes === null)
            throw new Error("The parameter 'excludeApiScopes' cannot be null.");
        else if (excludeApiScopes !== undefined)
            url_ += "excludeApiScopes=" + encodeURIComponent("" + excludeApiScopes) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetScopes(_response);
        });
    }

    protected processGetScopes(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    getGrantTypes(grant: string | null | undefined, includeObsoleteGrants: boolean | undefined, limit: number | undefined): Promise<SelectItemDto[]> {
        let url_ = this.baseUrl + "/api/Clients/GetGrantTypes?";
        if (grant !== undefined && grant !== null)
            url_ += "grant=" + encodeURIComponent("" + grant) + "&";
        if (includeObsoleteGrants === null)
            throw new Error("The parameter 'includeObsoleteGrants' cannot be null.");
        else if (includeObsoleteGrants !== undefined)
            url_ += "includeObsoleteGrants=" + encodeURIComponent("" + includeObsoleteGrants) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetGrantTypes(_response);
        });
    }

    protected processGetGrantTypes(response: Response): Promise<SelectItemDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SelectItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SelectItemDto[]>(null as any);
    }

    getHashTypes(): Promise<SelectItemDto[]> {
        let url_ = this.baseUrl + "/api/Clients/GetHashTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetHashTypes(_response);
        });
    }

    protected processGetHashTypes(response: Response): Promise<SelectItemDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SelectItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SelectItemDto[]>(null as any);
    }

    getSecretTypes(): Promise<SelectItemDto[]> {
        let url_ = this.baseUrl + "/api/Clients/GetSecretTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetSecretTypes(_response);
        });
    }

    protected processGetSecretTypes(response: Response): Promise<SelectItemDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SelectItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SelectItemDto[]>(null as any);
    }

    getStandardClaims(claim: string | null | undefined, limit: number | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/Clients/GetStandardClaims?";
        if (claim !== undefined && claim !== null)
            url_ += "claim=" + encodeURIComponent("" + claim) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetStandardClaims(_response);
        });
    }

    protected processGetStandardClaims(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    getSigningAlgorithms(algorithm: string | null | undefined, limit: number | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/Clients/GetSigningAlgorithms?";
        if (algorithm !== undefined && algorithm !== null)
            url_ += "algorithm=" + encodeURIComponent("" + algorithm) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetSigningAlgorithms(_response);
        });
    }

    protected processGetSigningAlgorithms(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    canInsertClient(id: number | undefined, clientId: string | null | undefined, isCloned: boolean | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Clients/CanInsertClient?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (clientId !== undefined && clientId !== null)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&";
        if (isCloned === null)
            throw new Error("The parameter 'isCloned' cannot be null.");
        else if (isCloned !== undefined)
            url_ += "isCloned=" + encodeURIComponent("" + isCloned) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCanInsertClient(_response);
        });
    }

    protected processCanInsertClient(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    postClientClone(client: ClientCloneApiDto): Promise<ClientApiDto> {
        let url_ = this.baseUrl + "/api/Clients/Clone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(client);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostClientClone(_response);
        });
    }

    protected processPostClientClone(response: Response): Promise<ClientApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ClientApiDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientApiDto>(null as any);
    }

    getSecrets(id: number, page: number | undefined, pageSize: number | undefined): Promise<ClientSecretsApiDto> {
        let url_ = this.baseUrl + "/api/Clients/{id}/Secrets?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetSecrets(_response);
        });
    }

    protected processGetSecrets(response: Response): Promise<ClientSecretsApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientSecretsApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientSecretsApiDto>(null as any);
    }

    postSecret(id: number, clientSecretApi: ClientSecretApiDto): Promise<ClientSecretApiDto> {
        let url_ = this.baseUrl + "/api/Clients/{id}/Secrets";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(clientSecretApi);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostSecret(_response);
        });
    }

    protected processPostSecret(response: Response): Promise<ClientSecretApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ClientSecretApiDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientSecretApiDto>(null as any);
    }

    getSecret(secretId: number): Promise<ClientSecretApiDto> {
        let url_ = this.baseUrl + "/api/Clients/Secrets/{secretId}";
        if (secretId === undefined || secretId === null)
            throw new Error("The parameter 'secretId' must be defined.");
        url_ = url_.replace("{secretId}", encodeURIComponent("" + secretId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetSecret(_response);
        });
    }

    protected processGetSecret(response: Response): Promise<ClientSecretApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientSecretApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientSecretApiDto>(null as any);
    }

    deleteSecret(secretId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Clients/Secrets/{secretId}";
        if (secretId === undefined || secretId === null)
            throw new Error("The parameter 'secretId' must be defined.");
        url_ = url_.replace("{secretId}", encodeURIComponent("" + secretId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteSecret(_response);
        });
    }

    protected processDeleteSecret(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getProperties(id: number, page: number | undefined, pageSize: number | undefined): Promise<ClientPropertiesApiDto> {
        let url_ = this.baseUrl + "/api/Clients/{id}/Properties?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProperties(_response);
        });
    }

    protected processGetProperties(response: Response): Promise<ClientPropertiesApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientPropertiesApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientPropertiesApiDto>(null as any);
    }

    postProperty(id: number, clientPropertyApi: ClientPropertyApiDto): Promise<ClientPropertyApiDto> {
        let url_ = this.baseUrl + "/api/Clients/{id}/Properties";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(clientPropertyApi);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostProperty(_response);
        });
    }

    protected processPostProperty(response: Response): Promise<ClientPropertyApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ClientPropertyApiDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientPropertyApiDto>(null as any);
    }

    getProperty(propertyId: number): Promise<ClientPropertyApiDto> {
        let url_ = this.baseUrl + "/api/Clients/Properties/{propertyId}";
        if (propertyId === undefined || propertyId === null)
            throw new Error("The parameter 'propertyId' must be defined.");
        url_ = url_.replace("{propertyId}", encodeURIComponent("" + propertyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProperty(_response);
        });
    }

    protected processGetProperty(response: Response): Promise<ClientPropertyApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientPropertyApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientPropertyApiDto>(null as any);
    }

    deleteProperty(propertyId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Clients/Properties/{propertyId}";
        if (propertyId === undefined || propertyId === null)
            throw new Error("The parameter 'propertyId' must be defined.");
        url_ = url_.replace("{propertyId}", encodeURIComponent("" + propertyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteProperty(_response);
        });
    }

    protected processDeleteProperty(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getClaims(id: number, page: number | undefined, pageSize: number | undefined): Promise<ClientClaimsApiDto> {
        let url_ = this.baseUrl + "/api/Clients/{id}/Claims?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetClaims(_response);
        });
    }

    protected processGetClaims(response: Response): Promise<ClientClaimsApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientClaimsApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientClaimsApiDto>(null as any);
    }

    postClaim(id: number, clientClaimApiDto: ClientClaimApiDto): Promise<ClientClaimApiDto> {
        let url_ = this.baseUrl + "/api/Clients/{id}/Claims";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(clientClaimApiDto);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostClaim(_response);
        });
    }

    protected processPostClaim(response: Response): Promise<ClientClaimApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ClientClaimApiDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientClaimApiDto>(null as any);
    }

    getClaim(claimId: number): Promise<ClientClaimApiDto> {
        let url_ = this.baseUrl + "/api/Clients/Claims/{claimId}";
        if (claimId === undefined || claimId === null)
            throw new Error("The parameter 'claimId' must be defined.");
        url_ = url_.replace("{claimId}", encodeURIComponent("" + claimId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetClaim(_response);
        });
    }

    protected processGetClaim(response: Response): Promise<ClientClaimApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientClaimApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientClaimApiDto>(null as any);
    }

    deleteClaim(claimId: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Clients/Claims/{claimId}";
        if (claimId === undefined || claimId === null)
            throw new Error("The parameter 'claimId' must be defined.");
        url_ = url_.replace("{claimId}", encodeURIComponent("" + claimId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteClaim(_response);
        });
    }

    protected processDeleteClaim(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export interface IConfigurationIssuesClient {

    get(): Promise<ConfigurationIssueDto[]>;

    getSummary(): Promise<ConfigurationIssueSummaryDto>;
}

export class ConfigurationIssuesClient extends WebApiClientBase implements IConfigurationIssuesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    get(): Promise<ConfigurationIssueDto[]> {
        let url_ = this.baseUrl + "/api/ConfigurationIssues";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ConfigurationIssueDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ConfigurationIssueDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ConfigurationIssueDto[]>(null as any);
    }

    getSummary(): Promise<ConfigurationIssueSummaryDto> {
        let url_ = this.baseUrl + "/api/ConfigurationIssues/GetSummary";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetSummary(_response);
        });
    }

    protected processGetSummary(response: Response): Promise<ConfigurationIssueSummaryDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConfigurationIssueSummaryDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ConfigurationIssueSummaryDto>(null as any);
    }
}

export interface IDashboardClient {

    getDashboardIdentityServer(auditLogsLastNumberOfDays: number | undefined): Promise<DashboardDto>;

    getDashboardIdentity(): Promise<DashboardIdentityDto>;
}

export class DashboardClient extends WebApiClientBase implements IDashboardClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getDashboardIdentityServer(auditLogsLastNumberOfDays: number | undefined): Promise<DashboardDto> {
        let url_ = this.baseUrl + "/api/Dashboard/GetDashboardIdentityServer?";
        if (auditLogsLastNumberOfDays === null)
            throw new Error("The parameter 'auditLogsLastNumberOfDays' cannot be null.");
        else if (auditLogsLastNumberOfDays !== undefined)
            url_ += "auditLogsLastNumberOfDays=" + encodeURIComponent("" + auditLogsLastNumberOfDays) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetDashboardIdentityServer(_response);
        });
    }

    protected processGetDashboardIdentityServer(response: Response): Promise<DashboardDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DashboardDto>(null as any);
    }

    getDashboardIdentity(): Promise<DashboardIdentityDto> {
        let url_ = this.baseUrl + "/api/Dashboard/GetDashboardIdentity";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetDashboardIdentity(_response);
        });
    }

    protected processGetDashboardIdentity(response: Response): Promise<DashboardIdentityDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardIdentityDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DashboardIdentityDto>(null as any);
    }
}

export interface IGoogleWorkspaceSyncClient {

    /**
     * 
     * @param tenantId (optional)  ID
     * @return 
     */
    preview(tenantId: string | null | undefined): Promise<GoogleSyncPreviewDto>;

    /**
     * 
     * @param tenantId (optional)  ID
     * @return 
     */
    syncOrganizations(tenantId: string | null | undefined): Promise<GoogleSyncResultDto>;

    /**
     * 
     * @param tenantId (optional)  ID
     * @param targetEmails (optional)  Email
     * @return 
     */
    syncMembers(tenantId: string | null | undefined, targetEmails: string | null | undefined): Promise<GoogleSyncResultDto>;

    /**
     *  + 
     * @param request 
     * @return 
     */
    fullSync(request: GoogleSyncRequestDto): Promise<GoogleSyncResultDto>;

    /**
     *  Google API 
     * @return 
     */
    healthCheck(): Promise<void>;
}

export class GoogleWorkspaceSyncClient extends WebApiClientBase implements IGoogleWorkspaceSyncClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * 
     * @param tenantId (optional)  ID
     * @return 
     */
    preview(tenantId: string | null | undefined): Promise<GoogleSyncPreviewDto> {
        let url_ = this.baseUrl + "/api/v2/google-sync/preview?";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPreview(_response);
        });
    }

    protected processPreview(response: Response): Promise<GoogleSyncPreviewDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GoogleSyncPreviewDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GoogleSyncPreviewDto>(null as any);
    }

    /**
     * 
     * @param tenantId (optional)  ID
     * @return 
     */
    syncOrganizations(tenantId: string | null | undefined): Promise<GoogleSyncResultDto> {
        let url_ = this.baseUrl + "/api/v2/google-sync/organizations?";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSyncOrganizations(_response);
        });
    }

    protected processSyncOrganizations(response: Response): Promise<GoogleSyncResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GoogleSyncResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GoogleSyncResultDto>(null as any);
    }

    /**
     * 
     * @param tenantId (optional)  ID
     * @param targetEmails (optional)  Email
     * @return 
     */
    syncMembers(tenantId: string | null | undefined, targetEmails: string | null | undefined): Promise<GoogleSyncResultDto> {
        let url_ = this.baseUrl + "/api/v2/google-sync/members?";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (targetEmails !== undefined && targetEmails !== null)
            url_ += "targetEmails=" + encodeURIComponent("" + targetEmails) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSyncMembers(_response);
        });
    }

    protected processSyncMembers(response: Response): Promise<GoogleSyncResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GoogleSyncResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GoogleSyncResultDto>(null as any);
    }

    /**
     *  + 
     * @param request 
     * @return 
     */
    fullSync(request: GoogleSyncRequestDto): Promise<GoogleSyncResultDto> {
        let url_ = this.baseUrl + "/api/v2/google-sync/full";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processFullSync(_response);
        });
    }

    protected processFullSync(response: Response): Promise<GoogleSyncResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GoogleSyncResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GoogleSyncResultDto>(null as any);
    }

    /**
     *  Google API 
     * @return 
     */
    healthCheck(): Promise<void> {
        let url_ = this.baseUrl + "/api/v2/google-sync/health";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processHealthCheck(_response);
        });
    }

    protected processHealthCheck(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IGroupClient {

    /**
     *  ( GroupType )
     * @param groupType (optional) 
     */
    getAll(groupType: string | null | undefined): Promise<GroupDto[]>;

    /**
     * 
     */
    create(dto: CreateGroupDto): Promise<GroupDto>;

    /**
     * 
     */
    getStats(): Promise<GroupStatsDto>;

    /**
     *  ID 
     */
    getById(id: string): Promise<GroupDto>;

    /**
     * 
     */
    update(id: string, dto: UpdateGroupDto): Promise<GroupDto>;

    /**
     *  (soft delete)
     */
    delete(id: string): Promise<OperationResultDto>;

    /**
     * 
     */
    getMembers(id: string): Promise<GroupMemberDetailDto[]>;

    /**
     * 
     */
    addMember(id: string, dto: AddGroupMemberDto): Promise<GroupMemberDetailDto>;

    /**
     * 
     */
    removeMember(id: string, userId: string): Promise<OperationResultDto>;
}

export class GroupClient extends WebApiClientBase implements IGroupClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     *  ( GroupType )
     * @param groupType (optional) 
     */
    getAll(groupType: string | null | undefined): Promise<GroupDto[]> {
        let url_ = this.baseUrl + "/api/v2/groups?";
        if (groupType !== undefined && groupType !== null)
            url_ += "groupType=" + encodeURIComponent("" + groupType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<GroupDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GroupDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GroupDto[]>(null as any);
    }

    /**
     * 
     */
    create(dto: CreateGroupDto): Promise<GroupDto> {
        let url_ = this.baseUrl + "/api/v2/groups";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<GroupDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = GroupDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GroupDto>(null as any);
    }

    /**
     * 
     */
    getStats(): Promise<GroupStatsDto> {
        let url_ = this.baseUrl + "/api/v2/groups/stats";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetStats(_response);
        });
    }

    protected processGetStats(response: Response): Promise<GroupStatsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GroupStatsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GroupStatsDto>(null as any);
    }

    /**
     *  ID 
     */
    getById(id: string): Promise<GroupDto> {
        let url_ = this.baseUrl + "/api/v2/groups/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: Response): Promise<GroupDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GroupDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GroupDto>(null as any);
    }

    /**
     * 
     */
    update(id: string, dto: UpdateGroupDto): Promise<GroupDto> {
        let url_ = this.baseUrl + "/api/v2/groups/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<GroupDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GroupDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GroupDto>(null as any);
    }

    /**
     *  (soft delete)
     */
    delete(id: string): Promise<OperationResultDto> {
        let url_ = this.baseUrl + "/api/v2/groups/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<OperationResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OperationResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OperationResultDto>(null as any);
    }

    /**
     * 
     */
    getMembers(id: string): Promise<GroupMemberDetailDto[]> {
        let url_ = this.baseUrl + "/api/v2/groups/{id}/members";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetMembers(_response);
        });
    }

    protected processGetMembers(response: Response): Promise<GroupMemberDetailDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GroupMemberDetailDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GroupMemberDetailDto[]>(null as any);
    }

    /**
     * 
     */
    addMember(id: string, dto: AddGroupMemberDto): Promise<GroupMemberDetailDto> {
        let url_ = this.baseUrl + "/api/v2/groups/{id}/members";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddMember(_response);
        });
    }

    protected processAddMember(response: Response): Promise<GroupMemberDetailDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = GroupMemberDetailDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GroupMemberDetailDto>(null as any);
    }

    /**
     * 
     */
    removeMember(id: string, userId: string): Promise<OperationResultDto> {
        let url_ = this.baseUrl + "/api/v2/groups/{id}/members/{userId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRemoveMember(_response);
        });
    }

    protected processRemoveMember(response: Response): Promise<OperationResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OperationResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OperationResultDto>(null as any);
    }
}

export interface IIdentityProvidersClient {

    get(searchText: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<IdentityProvidersApiDto>;

    post(identityProviderApi: IdentityProviderApiDto): Promise<void>;

    put(identityProviderApi: IdentityProviderApiDto): Promise<FileResponse>;

    canInsertIdentityProvider(id: number | undefined, schema: string | null | undefined): Promise<boolean>;

    get2(id: number): Promise<IdentityProviderApiDto>;

    delete(id: number): Promise<FileResponse>;
}

export class IdentityProvidersClient extends WebApiClientBase implements IIdentityProvidersClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    get(searchText: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<IdentityProvidersApiDto> {
        let url_ = this.baseUrl + "/api/IdentityProviders?";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<IdentityProvidersApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityProvidersApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityProvidersApiDto>(null as any);
    }

    post(identityProviderApi: IdentityProviderApiDto): Promise<void> {
        let url_ = this.baseUrl + "/api/IdentityProviders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(identityProviderApi);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    put(identityProviderApi: IdentityProviderApiDto): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/IdentityProviders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(identityProviderApi);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    canInsertIdentityProvider(id: number | undefined, schema: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/IdentityProviders/CanInsertIdentityProvider?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (schema !== undefined && schema !== null)
            url_ += "schema=" + encodeURIComponent("" + schema) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCanInsertIdentityProvider(_response);
        });
    }

    protected processCanInsertIdentityProvider(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    get2(id: number): Promise<IdentityProviderApiDto> {
        let url_ = this.baseUrl + "/api/IdentityProviders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet2(_response);
        });
    }

    protected processGet2(response: Response): Promise<IdentityProviderApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityProviderApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityProviderApiDto>(null as any);
    }

    delete(id: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/IdentityProviders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export interface IIdentityResourcesClient {

    get(searchText: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<IdentityResourcesApiDto>;

    post(identityResourceApi: IdentityResourceApiDto): Promise<IdentityResourceApiDto>;

    put(identityResourceApi: IdentityResourceApiDto): Promise<void>;

    get2(id: number): Promise<IdentityResourceApiDto>;

    delete(id: number): Promise<void>;

    canInsertIdentityResource(id: number | undefined, name: string | null | undefined): Promise<boolean>;

    canInsertIdentityResourceProperty(id: number | undefined, key: string | null | undefined): Promise<boolean>;

    getProperties(id: number, page: number | undefined, pageSize: number | undefined): Promise<IdentityResourcePropertiesApiDto>;

    postProperty(id: number, identityResourcePropertyApi: IdentityResourcePropertyApiDto): Promise<IdentityResourcePropertyApiDto>;

    getProperty(propertyId: number): Promise<IdentityResourcePropertyApiDto>;

    deleteProperty(propertyId: number): Promise<void>;
}

export class IdentityResourcesClient extends WebApiClientBase implements IIdentityResourcesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    get(searchText: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<IdentityResourcesApiDto> {
        let url_ = this.baseUrl + "/api/IdentityResources?";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<IdentityResourcesApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityResourcesApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityResourcesApiDto>(null as any);
    }

    post(identityResourceApi: IdentityResourceApiDto): Promise<IdentityResourceApiDto> {
        let url_ = this.baseUrl + "/api/IdentityResources";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(identityResourceApi);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<IdentityResourceApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = IdentityResourceApiDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityResourceApiDto>(null as any);
    }

    put(identityResourceApi: IdentityResourceApiDto): Promise<void> {
        let url_ = this.baseUrl + "/api/IdentityResources";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(identityResourceApi);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    get2(id: number): Promise<IdentityResourceApiDto> {
        let url_ = this.baseUrl + "/api/IdentityResources/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet2(_response);
        });
    }

    protected processGet2(response: Response): Promise<IdentityResourceApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityResourceApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityResourceApiDto>(null as any);
    }

    delete(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/IdentityResources/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    canInsertIdentityResource(id: number | undefined, name: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/IdentityResources/CanInsertIdentityResource?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCanInsertIdentityResource(_response);
        });
    }

    protected processCanInsertIdentityResource(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    canInsertIdentityResourceProperty(id: number | undefined, key: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/IdentityResources/CanInsertIdentityResourceProperty?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (key !== undefined && key !== null)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCanInsertIdentityResourceProperty(_response);
        });
    }

    protected processCanInsertIdentityResourceProperty(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    getProperties(id: number, page: number | undefined, pageSize: number | undefined): Promise<IdentityResourcePropertiesApiDto> {
        let url_ = this.baseUrl + "/api/IdentityResources/{id}/Properties?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProperties(_response);
        });
    }

    protected processGetProperties(response: Response): Promise<IdentityResourcePropertiesApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityResourcePropertiesApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityResourcePropertiesApiDto>(null as any);
    }

    postProperty(id: number, identityResourcePropertyApi: IdentityResourcePropertyApiDto): Promise<IdentityResourcePropertyApiDto> {
        let url_ = this.baseUrl + "/api/IdentityResources/{id}/Properties";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(identityResourcePropertyApi);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostProperty(_response);
        });
    }

    protected processPostProperty(response: Response): Promise<IdentityResourcePropertyApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = IdentityResourcePropertyApiDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityResourcePropertyApiDto>(null as any);
    }

    getProperty(propertyId: number): Promise<IdentityResourcePropertyApiDto> {
        let url_ = this.baseUrl + "/api/IdentityResources/Properties/{propertyId}";
        if (propertyId === undefined || propertyId === null)
            throw new Error("The parameter 'propertyId' must be defined.");
        url_ = url_.replace("{propertyId}", encodeURIComponent("" + propertyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProperty(_response);
        });
    }

    protected processGetProperty(response: Response): Promise<IdentityResourcePropertyApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityResourcePropertyApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityResourcePropertyApiDto>(null as any);
    }

    deleteProperty(propertyId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/IdentityResources/Properties/{propertyId}";
        if (propertyId === undefined || propertyId === null)
            throw new Error("The parameter 'propertyId' must be defined.");
        url_ = url_.replace("{propertyId}", encodeURIComponent("" + propertyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteProperty(_response);
        });
    }

    protected processDeleteProperty(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IInfoClient {

    getApplicationVersion(): Promise<string>;

    getApplicationName(): Promise<string>;
}

export class InfoClient extends WebApiClientBase implements IInfoClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getApplicationVersion(): Promise<string> {
        let url_ = this.baseUrl + "/api/Info/GetApplicationVersion";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetApplicationVersion(_response);
        });
    }

    protected processGetApplicationVersion(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    getApplicationName(): Promise<string> {
        let url_ = this.baseUrl + "/api/Info/GetApplicationName";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetApplicationName(_response);
        });
    }

    protected processGetApplicationName(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}

export interface IKeysClient {

    get(page: number | undefined, pageSize: number | undefined): Promise<KeysApiDto>;

    get2(id: string): Promise<KeyApiDto>;

    delete(id: string): Promise<FileResponse>;
}

export class KeysClient extends WebApiClientBase implements IKeysClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    get(page: number | undefined, pageSize: number | undefined): Promise<KeysApiDto> {
        let url_ = this.baseUrl + "/api/Keys?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<KeysApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KeysApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<KeysApiDto>(null as any);
    }

    get2(id: string): Promise<KeyApiDto> {
        let url_ = this.baseUrl + "/api/Keys/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet2(_response);
        });
    }

    protected processGet2(response: Response): Promise<KeyApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KeyApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<KeyApiDto>(null as any);
    }

    delete(id: string): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Keys/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export interface ILogsClient {

    auditLog(event: string | null | undefined, source: string | null | undefined, category: string | null | undefined, createdDate: string | null | undefined, subjectIdentifier: string | null | undefined, subjectName: string | null | undefined, pageSize: number | undefined, page: number | undefined): Promise<AuditLogsDto>;
}

export class LogsClient extends WebApiClientBase implements ILogsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    auditLog(event: string | null | undefined, source: string | null | undefined, category: string | null | undefined, createdDate: string | null | undefined, subjectIdentifier: string | null | undefined, subjectName: string | null | undefined, pageSize: number | undefined, page: number | undefined): Promise<AuditLogsDto> {
        let url_ = this.baseUrl + "/api/Logs/AuditLog?";
        if (event !== undefined && event !== null)
            url_ += "Event=" + encodeURIComponent("" + event) + "&";
        if (source !== undefined && source !== null)
            url_ += "Source=" + encodeURIComponent("" + source) + "&";
        if (category !== undefined && category !== null)
            url_ += "Category=" + encodeURIComponent("" + category) + "&";
        if (createdDate !== undefined && createdDate !== null)
            url_ += "CreatedDate=" + encodeURIComponent("" + createdDate) + "&";
        if (subjectIdentifier !== undefined && subjectIdentifier !== null)
            url_ += "SubjectIdentifier=" + encodeURIComponent("" + subjectIdentifier) + "&";
        if (subjectName !== undefined && subjectName !== null)
            url_ += "SubjectName=" + encodeURIComponent("" + subjectName) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAuditLog(_response);
        });
    }

    protected processAuditLog(response: Response): Promise<AuditLogsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuditLogsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuditLogsDto>(null as any);
    }
}

export interface IMultiTenantOrganizationClient {

    /**
     * 
     * @param tenantId (optional) 
     */
    getAll(tenantId: string | null | undefined): Promise<OrganizationDto[]>;

    /**
     * 
     * @param tenantId (optional) 
     */
    create(tenantId: string | null | undefined, dto: CreateOrganizationDto): Promise<OrganizationDto>;

    /**
     * 
     * @param tenantId (optional) 
     */
    getTree(tenantId: string | null | undefined): Promise<OrganizationTreeNodeDto[]>;

    /**
     *  ID 
     */
    getById(id: string): Promise<OrganizationDto>;

    /**
     * 
     */
    update(id: string, dto: UpdateOrganizationDto): Promise<OrganizationDto>;

    /**
     * 
     * @param includeDescendants (optional) 
     */
    delete(id: string, includeDescendants: boolean | undefined): Promise<OperationResultDto>;

    /**
     * 
     */
    getChildren(id: string): Promise<OrganizationDto[]>;

    /**
     * 
     * @param tenantId (optional) 
     */
    getStats(tenantId: string | null | undefined): Promise<OrganizationStatsDto>;

    /**
     * 
     */
    getMembers(id: string): Promise<OrganizationMemberDto[]>;

    /**
     * 
     */
    addMember(id: string, dto: AddOrganizationMemberDto): Promise<OrganizationMemberDto>;

    /**
     * 
     */
    removeMember(id: string, userId: string): Promise<OperationResultDto>;

    /**
     * 
     * @param tenantId (optional) 
     */
    getPositions(tenantId: string | null | undefined): Promise<PositionDto[]>;

    /**
     * 
     */
    getUserOrganizations(userId: string): Promise<OrganizationMemberDto[]>;
}

export class MultiTenantOrganizationClient extends WebApiClientBase implements IMultiTenantOrganizationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * 
     * @param tenantId (optional) 
     */
    getAll(tenantId: string | null | undefined): Promise<OrganizationDto[]> {
        let url_ = this.baseUrl + "/api/v2/organizations?";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<OrganizationDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrganizationDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrganizationDto[]>(null as any);
    }

    /**
     * 
     * @param tenantId (optional) 
     */
    create(tenantId: string | null | undefined, dto: CreateOrganizationDto): Promise<OrganizationDto> {
        let url_ = this.baseUrl + "/api/v2/organizations?";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<OrganizationDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = OrganizationDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrganizationDto>(null as any);
    }

    /**
     * 
     * @param tenantId (optional) 
     */
    getTree(tenantId: string | null | undefined): Promise<OrganizationTreeNodeDto[]> {
        let url_ = this.baseUrl + "/api/v2/organizations/tree?";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetTree(_response);
        });
    }

    protected processGetTree(response: Response): Promise<OrganizationTreeNodeDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrganizationTreeNodeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrganizationTreeNodeDto[]>(null as any);
    }

    /**
     *  ID 
     */
    getById(id: string): Promise<OrganizationDto> {
        let url_ = this.baseUrl + "/api/v2/organizations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: Response): Promise<OrganizationDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrganizationDto>(null as any);
    }

    /**
     * 
     */
    update(id: string, dto: UpdateOrganizationDto): Promise<OrganizationDto> {
        let url_ = this.baseUrl + "/api/v2/organizations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<OrganizationDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrganizationDto>(null as any);
    }

    /**
     * 
     * @param includeDescendants (optional) 
     */
    delete(id: string, includeDescendants: boolean | undefined): Promise<OperationResultDto> {
        let url_ = this.baseUrl + "/api/v2/organizations/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (includeDescendants === null)
            throw new Error("The parameter 'includeDescendants' cannot be null.");
        else if (includeDescendants !== undefined)
            url_ += "includeDescendants=" + encodeURIComponent("" + includeDescendants) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<OperationResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OperationResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OperationResultDto>(null as any);
    }

    /**
     * 
     */
    getChildren(id: string): Promise<OrganizationDto[]> {
        let url_ = this.baseUrl + "/api/v2/organizations/{id}/children";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetChildren(_response);
        });
    }

    protected processGetChildren(response: Response): Promise<OrganizationDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrganizationDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrganizationDto[]>(null as any);
    }

    /**
     * 
     * @param tenantId (optional) 
     */
    getStats(tenantId: string | null | undefined): Promise<OrganizationStatsDto> {
        let url_ = this.baseUrl + "/api/v2/organizations/stats?";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetStats(_response);
        });
    }

    protected processGetStats(response: Response): Promise<OrganizationStatsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationStatsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrganizationStatsDto>(null as any);
    }

    /**
     * 
     */
    getMembers(id: string): Promise<OrganizationMemberDto[]> {
        let url_ = this.baseUrl + "/api/v2/organizations/{id}/members";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetMembers(_response);
        });
    }

    protected processGetMembers(response: Response): Promise<OrganizationMemberDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrganizationMemberDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrganizationMemberDto[]>(null as any);
    }

    /**
     * 
     */
    addMember(id: string, dto: AddOrganizationMemberDto): Promise<OrganizationMemberDto> {
        let url_ = this.baseUrl + "/api/v2/organizations/{id}/members";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddMember(_response);
        });
    }

    protected processAddMember(response: Response): Promise<OrganizationMemberDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = OrganizationMemberDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrganizationMemberDto>(null as any);
    }

    /**
     * 
     */
    removeMember(id: string, userId: string): Promise<OperationResultDto> {
        let url_ = this.baseUrl + "/api/v2/organizations/{id}/members/{userId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRemoveMember(_response);
        });
    }

    protected processRemoveMember(response: Response): Promise<OperationResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OperationResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OperationResultDto>(null as any);
    }

    /**
     * 
     * @param tenantId (optional) 
     */
    getPositions(tenantId: string | null | undefined): Promise<PositionDto[]> {
        let url_ = this.baseUrl + "/api/v2/organizations/positions?";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetPositions(_response);
        });
    }

    protected processGetPositions(response: Response): Promise<PositionDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PositionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PositionDto[]>(null as any);
    }

    /**
     * 
     */
    getUserOrganizations(userId: string): Promise<OrganizationMemberDto[]> {
        let url_ = this.baseUrl + "/api/v2/organizations/users/{userId}/organizations";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUserOrganizations(_response);
        });
    }

    protected processGetUserOrganizations(response: Response): Promise<OrganizationMemberDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrganizationMemberDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrganizationMemberDto[]>(null as any);
    }
}

export interface IMultiTenantPermissionClient {

    /**
     * 
     * @param clientId (optional) 
     */
    getResources(clientId: string | null | undefined): Promise<PermissionResourceDto[]>;

    /**
     * 
     * @param clientId (optional) 
     */
    getResourceTree(clientId: string | null | undefined): Promise<PermissionResourceDto[]>;

    /**
     *  ID 
     */
    getResourceById(id: string): Promise<PermissionResourceDto>;

    /**
     * 
     */
    getScopes(): Promise<PermissionScopeDto[]>;

    /**
     * 
     */
    getUserPermissions(userId: string): Promise<PermissionDto[]>;

    /**
     * 
     */
    getUserEffectivePermissions(userId: string): Promise<UserEffectivePermissionsDto>;

    /**
     * 
     * @param resourceId (optional) 
     * @param clientId (optional) 
     * @param resourceCode (optional) 
     * @param scope (optional) 
     */
    checkUserPermission(userId: string, resourceId: string | null | undefined, clientId: string | null | undefined, resourceCode: string | null | undefined, scope: string | null | undefined): Promise<PermissionCheckResultDto>;

    /**
     * 
     */
    getOrganizationPermissions(organizationId: string): Promise<PermissionDto[]>;

    /**
     * 
     */
    getGroupPermissions(groupId: string): Promise<PermissionDto[]>;

    /**
     * 
     */
    getResourcePermissions(resourceId: string): Promise<PermissionDto[]>;

    /**
     * 
     */
    grantPermission(dto: GrantPermissionDto): Promise<PermissionDto>;

    /**
     * 
     */
    batchGrantPermissions(dto: BatchGrantPermissionDto): Promise<PermissionDto[]>;

    /**
     * 
     */
    revokePermission(id: string): Promise<OperationResultDto>;

    /**
     * 
     */
    updatePermission(id: string, dto: UpdatePermissionDto): Promise<PermissionDto>;

    /**
     * 
     */
    batchRevokePermissions(permissionIds: string[]): Promise<OperationResultDto>;
}

export class MultiTenantPermissionClient extends WebApiClientBase implements IMultiTenantPermissionClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * 
     * @param clientId (optional) 
     */
    getResources(clientId: string | null | undefined): Promise<PermissionResourceDto[]> {
        let url_ = this.baseUrl + "/api/v2/permissions/resources?";
        if (clientId !== undefined && clientId !== null)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetResources(_response);
        });
    }

    protected processGetResources(response: Response): Promise<PermissionResourceDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PermissionResourceDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionResourceDto[]>(null as any);
    }

    /**
     * 
     * @param clientId (optional) 
     */
    getResourceTree(clientId: string | null | undefined): Promise<PermissionResourceDto[]> {
        let url_ = this.baseUrl + "/api/v2/permissions/resources/tree?";
        if (clientId !== undefined && clientId !== null)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetResourceTree(_response);
        });
    }

    protected processGetResourceTree(response: Response): Promise<PermissionResourceDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PermissionResourceDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionResourceDto[]>(null as any);
    }

    /**
     *  ID 
     */
    getResourceById(id: string): Promise<PermissionResourceDto> {
        let url_ = this.baseUrl + "/api/v2/permissions/resources/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetResourceById(_response);
        });
    }

    protected processGetResourceById(response: Response): Promise<PermissionResourceDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionResourceDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionResourceDto>(null as any);
    }

    /**
     * 
     */
    getScopes(): Promise<PermissionScopeDto[]> {
        let url_ = this.baseUrl + "/api/v2/permissions/scopes";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetScopes(_response);
        });
    }

    protected processGetScopes(response: Response): Promise<PermissionScopeDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PermissionScopeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionScopeDto[]>(null as any);
    }

    /**
     * 
     */
    getUserPermissions(userId: string): Promise<PermissionDto[]> {
        let url_ = this.baseUrl + "/api/v2/permissions/users/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUserPermissions(_response);
        });
    }

    protected processGetUserPermissions(response: Response): Promise<PermissionDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PermissionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionDto[]>(null as any);
    }

    /**
     * 
     */
    getUserEffectivePermissions(userId: string): Promise<UserEffectivePermissionsDto> {
        let url_ = this.baseUrl + "/api/v2/permissions/users/{userId}/effective";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUserEffectivePermissions(_response);
        });
    }

    protected processGetUserEffectivePermissions(response: Response): Promise<UserEffectivePermissionsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserEffectivePermissionsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserEffectivePermissionsDto>(null as any);
    }

    /**
     * 
     * @param resourceId (optional) 
     * @param clientId (optional) 
     * @param resourceCode (optional) 
     * @param scope (optional) 
     */
    checkUserPermission(userId: string, resourceId: string | null | undefined, clientId: string | null | undefined, resourceCode: string | null | undefined, scope: string | null | undefined): Promise<PermissionCheckResultDto> {
        let url_ = this.baseUrl + "/api/v2/permissions/users/{userId}/check?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (resourceId !== undefined && resourceId !== null)
            url_ += "resourceId=" + encodeURIComponent("" + resourceId) + "&";
        if (clientId !== undefined && clientId !== null)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&";
        if (resourceCode !== undefined && resourceCode !== null)
            url_ += "resourceCode=" + encodeURIComponent("" + resourceCode) + "&";
        if (scope !== undefined && scope !== null)
            url_ += "scope=" + encodeURIComponent("" + scope) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCheckUserPermission(_response);
        });
    }

    protected processCheckUserPermission(response: Response): Promise<PermissionCheckResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionCheckResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionCheckResultDto>(null as any);
    }

    /**
     * 
     */
    getOrganizationPermissions(organizationId: string): Promise<PermissionDto[]> {
        let url_ = this.baseUrl + "/api/v2/permissions/organizations/{organizationId}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetOrganizationPermissions(_response);
        });
    }

    protected processGetOrganizationPermissions(response: Response): Promise<PermissionDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PermissionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionDto[]>(null as any);
    }

    /**
     * 
     */
    getGroupPermissions(groupId: string): Promise<PermissionDto[]> {
        let url_ = this.baseUrl + "/api/v2/permissions/groups/{groupId}";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetGroupPermissions(_response);
        });
    }

    protected processGetGroupPermissions(response: Response): Promise<PermissionDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PermissionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionDto[]>(null as any);
    }

    /**
     * 
     */
    getResourcePermissions(resourceId: string): Promise<PermissionDto[]> {
        let url_ = this.baseUrl + "/api/v2/permissions/resources/{resourceId}/permissions";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetResourcePermissions(_response);
        });
    }

    protected processGetResourcePermissions(response: Response): Promise<PermissionDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PermissionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionDto[]>(null as any);
    }

    /**
     * 
     */
    grantPermission(dto: GrantPermissionDto): Promise<PermissionDto> {
        let url_ = this.baseUrl + "/api/v2/permissions/grant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGrantPermission(_response);
        });
    }

    protected processGrantPermission(response: Response): Promise<PermissionDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = PermissionDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionDto>(null as any);
    }

    /**
     * 
     */
    batchGrantPermissions(dto: BatchGrantPermissionDto): Promise<PermissionDto[]> {
        let url_ = this.baseUrl + "/api/v2/permissions/grant/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBatchGrantPermissions(_response);
        });
    }

    protected processBatchGrantPermissions(response: Response): Promise<PermissionDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201!.push(PermissionDto.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionDto[]>(null as any);
    }

    /**
     * 
     */
    revokePermission(id: string): Promise<OperationResultDto> {
        let url_ = this.baseUrl + "/api/v2/permissions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRevokePermission(_response);
        });
    }

    protected processRevokePermission(response: Response): Promise<OperationResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OperationResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OperationResultDto>(null as any);
    }

    /**
     * 
     */
    updatePermission(id: string, dto: UpdatePermissionDto): Promise<PermissionDto> {
        let url_ = this.baseUrl + "/api/v2/permissions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdatePermission(_response);
        });
    }

    protected processUpdatePermission(response: Response): Promise<PermissionDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionDto>(null as any);
    }

    /**
     * 
     */
    batchRevokePermissions(permissionIds: string[]): Promise<OperationResultDto> {
        let url_ = this.baseUrl + "/api/v2/permissions/revoke/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(permissionIds);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBatchRevokePermissions(_response);
        });
    }

    protected processBatchRevokePermissions(response: Response): Promise<OperationResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OperationResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OperationResultDto>(null as any);
    }
}

export interface IOidcClient {

    /**
     * Discovery Document -  OIDC 
     * @return Discovery Document JSON
     */
    getDiscoveryDocument(): Promise<any>;

    /**
     * Authorization Endpoint -  URL
     * @param request 
     * @return  URL
     */
    getAuthorizeUrl(request: AuthorizeUrlRequest): Promise<AuthorizeUrlResponse>;

    /**
     * Token Endpoint -  Token
     * @param request Token 
     * @return Token Response
     */
    exchangeToken(request: TokenRequest): Promise<any>;

    /**
     * Token Refresh -  Access Token
     * @param request 
     * @return Token Response
     */
    refreshToken(request: RefreshTokenRequest): Promise<any>;

    /**
     * Client Credentials - 
     * @param request Client Credentials 
     * @return Token Response
     */
    getClientCredentialsToken(request: ClientCredentialsRequest): Promise<any>;

    /**
     * Introspection Endpoint - Token 
     * @param request 
     * @return Token 
     */
    introspectToken(request: IntrospectRequest): Promise<any>;

    /**
     * Revocation Endpoint - Token 
     * @param request 
     * @return 
     */
    revokeToken(request: RevokeRequest): Promise<RevokeResponse>;

    /**
     * UserInfo Endpoint - 
     * @param accessToken (optional) Access Token
     * @return 
     */
    getUserInfo(accessToken: string | null | undefined): Promise<any>;

    /**
     * End Session Endpoint -  URL
     * @param request 
     * @return  URL
     */
    getLogoutUrl(request: LogoutUrlRequest): Promise<LogoutUrlResponse>;
}

export class OidcClient extends WebApiClientBase implements IOidcClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Discovery Document -  OIDC 
     * @return Discovery Document JSON
     */
    getDiscoveryDocument(): Promise<any> {
        let url_ = this.baseUrl + "/.well-known/openid-configuration";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetDiscoveryDocument(_response);
        });
    }

    protected processGetDiscoveryDocument(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Authorization Endpoint -  URL
     * @param request 
     * @return  URL
     */
    getAuthorizeUrl(request: AuthorizeUrlRequest): Promise<AuthorizeUrlResponse> {
        let url_ = this.baseUrl + "/connect/authorize-url";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAuthorizeUrl(_response);
        });
    }

    protected processGetAuthorizeUrl(response: Response): Promise<AuthorizeUrlResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthorizeUrlResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuthorizeUrlResponse>(null as any);
    }

    /**
     * Token Endpoint -  Token
     * @param request Token 
     * @return Token Response
     */
    exchangeToken(request: TokenRequest): Promise<any> {
        let url_ = this.baseUrl + "/connect/token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processExchangeToken(_response);
        });
    }

    protected processExchangeToken(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Token Refresh -  Access Token
     * @param request 
     * @return Token Response
     */
    refreshToken(request: RefreshTokenRequest): Promise<any> {
        let url_ = this.baseUrl + "/connect/token/refresh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRefreshToken(_response);
        });
    }

    protected processRefreshToken(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Client Credentials - 
     * @param request Client Credentials 
     * @return Token Response
     */
    getClientCredentialsToken(request: ClientCredentialsRequest): Promise<any> {
        let url_ = this.baseUrl + "/connect/token/client-credentials";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetClientCredentialsToken(_response);
        });
    }

    protected processGetClientCredentialsToken(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Introspection Endpoint - Token 
     * @param request 
     * @return Token 
     */
    introspectToken(request: IntrospectRequest): Promise<any> {
        let url_ = this.baseUrl + "/connect/introspect";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processIntrospectToken(_response);
        });
    }

    protected processIntrospectToken(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Revocation Endpoint - Token 
     * @param request 
     * @return 
     */
    revokeToken(request: RevokeRequest): Promise<RevokeResponse> {
        let url_ = this.baseUrl + "/connect/revocation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRevokeToken(_response);
        });
    }

    protected processRevokeToken(response: Response): Promise<RevokeResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RevokeResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RevokeResponse>(null as any);
    }

    /**
     * UserInfo Endpoint - 
     * @param accessToken (optional) Access Token
     * @return 
     */
    getUserInfo(accessToken: string | null | undefined): Promise<any> {
        let url_ = this.baseUrl + "/connect/userinfo?";
        if (accessToken !== undefined && accessToken !== null)
            url_ += "accessToken=" + encodeURIComponent("" + accessToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUserInfo(_response);
        });
    }

    protected processGetUserInfo(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * End Session Endpoint -  URL
     * @param request 
     * @return  URL
     */
    getLogoutUrl(request: LogoutUrlRequest): Promise<LogoutUrlResponse> {
        let url_ = this.baseUrl + "/connect/endsession-url";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetLogoutUrl(_response);
        });
    }

    protected processGetLogoutUrl(response: Response): Promise<LogoutUrlResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LogoutUrlResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LogoutUrlResponse>(null as any);
    }
}

export interface IOrganizationClient {

    /**
     * 
     */
    getAll(): Promise<OrganizationGroupApiDto[]>;

    /**
     * 
     */
    create(dto: CreateOrganizationGroupApiDto): Promise<OrganizationGroupApiDto>;

    /**
     * 
     */
    getTree(): Promise<OrganizationTreeApiDto[]>;

    /**
     *  ID 
     */
    getById(id: string): Promise<OrganizationGroupApiDto>;

    /**
     * 
     */
    update(id: string, dto: UpdateOrganizationGroupApiDto): Promise<OrganizationGroupApiDto>;

    /**
     * 
     */
    delete(id: string): Promise<DeleteResultApiDto>;

    /**
     * 
     */
    getStats(): Promise<OrganizationStatsApiDto>;

    /**
     * 
     * @param name (optional) 
     * @param parentId (optional) 
     * @param excludeId (optional) 
     */
    canInsert(name: string | null | undefined, parentId: string | null | undefined, excludeId: string | null | undefined): Promise<boolean>;

    /**
     * 
     */
    getDeleteConfirmation(id: string): Promise<DeleteConfirmationApiDto>;

    /**
     * 
     */
    getMembers(id: string): Promise<GroupMemberApiDto[]>;
}

export class OrganizationClient extends WebApiClientBase implements IOrganizationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * 
     */
    getAll(): Promise<OrganizationGroupApiDto[]> {
        let url_ = this.baseUrl + "/api/Organization";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<OrganizationGroupApiDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrganizationGroupApiDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrganizationGroupApiDto[]>(null as any);
    }

    /**
     * 
     */
    create(dto: CreateOrganizationGroupApiDto): Promise<OrganizationGroupApiDto> {
        let url_ = this.baseUrl + "/api/Organization";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<OrganizationGroupApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = OrganizationGroupApiDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrganizationGroupApiDto>(null as any);
    }

    /**
     * 
     */
    getTree(): Promise<OrganizationTreeApiDto[]> {
        let url_ = this.baseUrl + "/api/Organization/tree";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetTree(_response);
        });
    }

    protected processGetTree(response: Response): Promise<OrganizationTreeApiDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrganizationTreeApiDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrganizationTreeApiDto[]>(null as any);
    }

    /**
     *  ID 
     */
    getById(id: string): Promise<OrganizationGroupApiDto> {
        let url_ = this.baseUrl + "/api/Organization/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: Response): Promise<OrganizationGroupApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationGroupApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrganizationGroupApiDto>(null as any);
    }

    /**
     * 
     */
    update(id: string, dto: UpdateOrganizationGroupApiDto): Promise<OrganizationGroupApiDto> {
        let url_ = this.baseUrl + "/api/Organization/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<OrganizationGroupApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationGroupApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrganizationGroupApiDto>(null as any);
    }

    /**
     * 
     */
    delete(id: string): Promise<DeleteResultApiDto> {
        let url_ = this.baseUrl + "/api/Organization/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<DeleteResultApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeleteResultApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeleteResultApiDto>(null as any);
    }

    /**
     * 
     */
    getStats(): Promise<OrganizationStatsApiDto> {
        let url_ = this.baseUrl + "/api/Organization/stats";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetStats(_response);
        });
    }

    protected processGetStats(response: Response): Promise<OrganizationStatsApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationStatsApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrganizationStatsApiDto>(null as any);
    }

    /**
     * 
     * @param name (optional) 
     * @param parentId (optional) 
     * @param excludeId (optional) 
     */
    canInsert(name: string | null | undefined, parentId: string | null | undefined, excludeId: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Organization/check-name?";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (parentId !== undefined && parentId !== null)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&";
        if (excludeId !== undefined && excludeId !== null)
            url_ += "excludeId=" + encodeURIComponent("" + excludeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCanInsert(_response);
        });
    }

    protected processCanInsert(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * 
     */
    getDeleteConfirmation(id: string): Promise<DeleteConfirmationApiDto> {
        let url_ = this.baseUrl + "/api/Organization/{id}/delete-confirmation";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetDeleteConfirmation(_response);
        });
    }

    protected processGetDeleteConfirmation(response: Response): Promise<DeleteConfirmationApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeleteConfirmationApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeleteConfirmationApiDto>(null as any);
    }

    /**
     * 
     */
    getMembers(id: string): Promise<GroupMemberApiDto[]> {
        let url_ = this.baseUrl + "/api/Organization/{id}/members";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetMembers(_response);
        });
    }

    protected processGetMembers(response: Response): Promise<GroupMemberApiDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GroupMemberApiDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GroupMemberApiDto[]>(null as any);
    }
}

export interface IPermissionClient {

    /**
     * 
     */
    getStats(): Promise<PermissionStatsDto>;

    /**
     *  ID 
     */
    getClients(): Promise<string[]>;

    /**
     * 
     * @param search (optional) 
     */
    searchUsers(search: string | null | undefined): Promise<UserBriefDto[]>;

    /**
     * 
     */
    getGroups(): Promise<GroupBriefDto[]>;

    /**
     * 
     * @param clientId (optional) 
     */
    getAllScopes(clientId: string | null | undefined): Promise<ScopeDto[]>;

    /**
     * 
     */
    createScope(dto: CreateScopeDto): Promise<ScopeDto>;

    /**
     *  ID 
     * @param clientId (optional) 
     */
    getScopeById(id: string, clientId: string | null | undefined): Promise<ScopeDto>;

    /**
     * 
     */
    updateScope(id: string, dto: UpdateScopeDto): Promise<ScopeDto>;

    /**
     * 
     * @param clientId (optional) 
     */
    deleteScope(id: string, clientId: string | null | undefined): Promise<void>;

    /**
     * 
     * @param name (optional) 
     * @param clientId (optional) 
     * @param excludeId (optional) 
     */
    canInsertScope(name: string | null | undefined, clientId: string | null | undefined, excludeId: string | null | undefined): Promise<boolean>;

    /**
     * 
     * @param clientId (optional) 
     * @param type (optional) 
     */
    getAllResources(clientId: string | null | undefined, type: string | null | undefined): Promise<ResourceDto[]>;

    /**
     * 
     */
    createResource(dto: CreateResourceDto): Promise<ResourceDto>;

    /**
     *  ID 
     * @param clientId (optional) 
     */
    getResourceById(id: string, clientId: string | null | undefined): Promise<ResourceDto>;

    /**
     * 
     */
    updateResource(id: string, dto: UpdateResourceDto): Promise<ResourceDto>;

    /**
     * 
     * @param clientId (optional) 
     */
    deleteResource(id: string, clientId: string | null | undefined): Promise<void>;

    /**
     * 
     * @param name (optional) 
     * @param clientId (optional) 
     * @param excludeId (optional) 
     */
    canInsertResource(name: string | null | undefined, clientId: string | null | undefined, excludeId: string | null | undefined): Promise<boolean>;

    /**
     * 
     * @param clientId (optional) 
     */
    getResourceScopes(resourceId: string, clientId: string | null | undefined): Promise<ResourceScopeDto2[]>;

    /**
     * 
     * @param clientId (optional) 
     */
    setResourceScopes(resourceId: string, clientId: string | null | undefined, scopeIds: string[]): Promise<number>;

    /**
     * 
     * @param clientId (optional) 
     */
    getUserPermissions(userId: string, clientId: string | null | undefined): Promise<UserPermissionDto[]>;

    /**
     * 
     */
    setUserPermission(userId: string, dto: SetUserPermissionDto): Promise<UserPermissionDto>;

    /**
     * 
     * @param clientId (optional) 
     * @param resourceId (optional) 
     */
    removeUserPermission(userId: string, clientId: string | null | undefined, resourceId: string | null | undefined): Promise<void>;

    /**
     * 
     * @param clientId (optional) 
     */
    getResourceUserPermissions(resourceId: string, clientId: string | null | undefined): Promise<UserPermissionDto[]>;

    /**
     * 
     * @param clientId (optional) 
     */
    getUserEffectivePermissions(userId: string, clientId: string | null | undefined): Promise<EffectivePermissionDto2[]>;

    /**
     * 
     * @param clientId (optional) 
     * @param resourceId (optional) 
     * @param scope (optional) 
     */
    hasPermission(userId: string, clientId: string | null | undefined, resourceId: string | null | undefined, scope: string | null | undefined): Promise<boolean>;

    /**
     * 
     * @param clientId (optional) 
     */
    getGroupPermissions(groupId: string, clientId: string | null | undefined): Promise<GroupPermissionDto[]>;

    /**
     * 
     */
    setGroupPermission(groupId: string, dto: SetGroupPermissionDto): Promise<GroupPermissionDto>;

    /**
     * 
     * @param clientId (optional) 
     * @param resourceId (optional) 
     */
    removeGroupPermission(groupId: string, clientId: string | null | undefined, resourceId: string | null | undefined): Promise<void>;

    /**
     * 
     * @param clientId (optional) 
     */
    getResourceGroupPermissions(resourceId: string, clientId: string | null | undefined): Promise<GroupPermissionDto[]>;
}

export class PermissionClient extends WebApiClientBase implements IPermissionClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * 
     */
    getStats(): Promise<PermissionStatsDto> {
        let url_ = this.baseUrl + "/api/Permission/stats";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetStats(_response);
        });
    }

    protected processGetStats(response: Response): Promise<PermissionStatsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionStatsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionStatsDto>(null as any);
    }

    /**
     *  ID 
     */
    getClients(): Promise<string[]> {
        let url_ = this.baseUrl + "/api/Permission/clients";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetClients(_response);
        });
    }

    protected processGetClients(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * 
     * @param search (optional) 
     */
    searchUsers(search: string | null | undefined): Promise<UserBriefDto[]> {
        let url_ = this.baseUrl + "/api/Permission/users/search?";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchUsers(_response);
        });
    }

    protected processSearchUsers(response: Response): Promise<UserBriefDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserBriefDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserBriefDto[]>(null as any);
    }

    /**
     * 
     */
    getGroups(): Promise<GroupBriefDto[]> {
        let url_ = this.baseUrl + "/api/Permission/groups";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetGroups(_response);
        });
    }

    protected processGetGroups(response: Response): Promise<GroupBriefDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GroupBriefDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GroupBriefDto[]>(null as any);
    }

    /**
     * 
     * @param clientId (optional) 
     */
    getAllScopes(clientId: string | null | undefined): Promise<ScopeDto[]> {
        let url_ = this.baseUrl + "/api/Permission/scopes?";
        if (clientId !== undefined && clientId !== null)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAllScopes(_response);
        });
    }

    protected processGetAllScopes(response: Response): Promise<ScopeDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ScopeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ScopeDto[]>(null as any);
    }

    /**
     * 
     */
    createScope(dto: CreateScopeDto): Promise<ScopeDto> {
        let url_ = this.baseUrl + "/api/Permission/scopes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateScope(_response);
        });
    }

    protected processCreateScope(response: Response): Promise<ScopeDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ScopeDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ScopeDto>(null as any);
    }

    /**
     *  ID 
     * @param clientId (optional) 
     */
    getScopeById(id: string, clientId: string | null | undefined): Promise<ScopeDto> {
        let url_ = this.baseUrl + "/api/Permission/scopes/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (clientId !== undefined && clientId !== null)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetScopeById(_response);
        });
    }

    protected processGetScopeById(response: Response): Promise<ScopeDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScopeDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ScopeDto>(null as any);
    }

    /**
     * 
     */
    updateScope(id: string, dto: UpdateScopeDto): Promise<ScopeDto> {
        let url_ = this.baseUrl + "/api/Permission/scopes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateScope(_response);
        });
    }

    protected processUpdateScope(response: Response): Promise<ScopeDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScopeDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ScopeDto>(null as any);
    }

    /**
     * 
     * @param clientId (optional) 
     */
    deleteScope(id: string, clientId: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Permission/scopes/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (clientId !== undefined && clientId !== null)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteScope(_response);
        });
    }

    protected processDeleteScope(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 
     * @param name (optional) 
     * @param clientId (optional) 
     * @param excludeId (optional) 
     */
    canInsertScope(name: string | null | undefined, clientId: string | null | undefined, excludeId: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Permission/scopes/check-name?";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (clientId !== undefined && clientId !== null)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&";
        if (excludeId !== undefined && excludeId !== null)
            url_ += "excludeId=" + encodeURIComponent("" + excludeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCanInsertScope(_response);
        });
    }

    protected processCanInsertScope(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * 
     * @param clientId (optional) 
     * @param type (optional) 
     */
    getAllResources(clientId: string | null | undefined, type: string | null | undefined): Promise<ResourceDto[]> {
        let url_ = this.baseUrl + "/api/Permission/resources?";
        if (clientId !== undefined && clientId !== null)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&";
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAllResources(_response);
        });
    }

    protected processGetAllResources(response: Response): Promise<ResourceDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ResourceDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResourceDto[]>(null as any);
    }

    /**
     * 
     */
    createResource(dto: CreateResourceDto): Promise<ResourceDto> {
        let url_ = this.baseUrl + "/api/Permission/resources";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateResource(_response);
        });
    }

    protected processCreateResource(response: Response): Promise<ResourceDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ResourceDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResourceDto>(null as any);
    }

    /**
     *  ID 
     * @param clientId (optional) 
     */
    getResourceById(id: string, clientId: string | null | undefined): Promise<ResourceDto> {
        let url_ = this.baseUrl + "/api/Permission/resources/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (clientId !== undefined && clientId !== null)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetResourceById(_response);
        });
    }

    protected processGetResourceById(response: Response): Promise<ResourceDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResourceDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResourceDto>(null as any);
    }

    /**
     * 
     */
    updateResource(id: string, dto: UpdateResourceDto): Promise<ResourceDto> {
        let url_ = this.baseUrl + "/api/Permission/resources/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateResource(_response);
        });
    }

    protected processUpdateResource(response: Response): Promise<ResourceDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResourceDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResourceDto>(null as any);
    }

    /**
     * 
     * @param clientId (optional) 
     */
    deleteResource(id: string, clientId: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Permission/resources/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (clientId !== undefined && clientId !== null)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteResource(_response);
        });
    }

    protected processDeleteResource(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 
     * @param name (optional) 
     * @param clientId (optional) 
     * @param excludeId (optional) 
     */
    canInsertResource(name: string | null | undefined, clientId: string | null | undefined, excludeId: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Permission/resources/check-name?";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (clientId !== undefined && clientId !== null)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&";
        if (excludeId !== undefined && excludeId !== null)
            url_ += "excludeId=" + encodeURIComponent("" + excludeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCanInsertResource(_response);
        });
    }

    protected processCanInsertResource(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * 
     * @param clientId (optional) 
     */
    getResourceScopes(resourceId: string, clientId: string | null | undefined): Promise<ResourceScopeDto2[]> {
        let url_ = this.baseUrl + "/api/Permission/resources/{resourceId}/scopes?";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (clientId !== undefined && clientId !== null)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetResourceScopes(_response);
        });
    }

    protected processGetResourceScopes(response: Response): Promise<ResourceScopeDto2[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ResourceScopeDto2.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResourceScopeDto2[]>(null as any);
    }

    /**
     * 
     * @param clientId (optional) 
     */
    setResourceScopes(resourceId: string, clientId: string | null | undefined, scopeIds: string[]): Promise<number> {
        let url_ = this.baseUrl + "/api/Permission/resources/{resourceId}/scopes?";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (clientId !== undefined && clientId !== null)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(scopeIds);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSetResourceScopes(_response);
        });
    }

    protected processSetResourceScopes(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * 
     * @param clientId (optional) 
     */
    getUserPermissions(userId: string, clientId: string | null | undefined): Promise<UserPermissionDto[]> {
        let url_ = this.baseUrl + "/api/Permission/users/{userId}/permissions?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (clientId !== undefined && clientId !== null)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUserPermissions(_response);
        });
    }

    protected processGetUserPermissions(response: Response): Promise<UserPermissionDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserPermissionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserPermissionDto[]>(null as any);
    }

    /**
     * 
     */
    setUserPermission(userId: string, dto: SetUserPermissionDto): Promise<UserPermissionDto> {
        let url_ = this.baseUrl + "/api/Permission/users/{userId}/permissions";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSetUserPermission(_response);
        });
    }

    protected processSetUserPermission(response: Response): Promise<UserPermissionDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserPermissionDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserPermissionDto>(null as any);
    }

    /**
     * 
     * @param clientId (optional) 
     * @param resourceId (optional) 
     */
    removeUserPermission(userId: string, clientId: string | null | undefined, resourceId: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Permission/users/{userId}/permissions?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (clientId !== undefined && clientId !== null)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&";
        if (resourceId !== undefined && resourceId !== null)
            url_ += "resourceId=" + encodeURIComponent("" + resourceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRemoveUserPermission(_response);
        });
    }

    protected processRemoveUserPermission(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 
     * @param clientId (optional) 
     */
    getResourceUserPermissions(resourceId: string, clientId: string | null | undefined): Promise<UserPermissionDto[]> {
        let url_ = this.baseUrl + "/api/Permission/resources/{resourceId}/user-permissions?";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (clientId !== undefined && clientId !== null)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetResourceUserPermissions(_response);
        });
    }

    protected processGetResourceUserPermissions(response: Response): Promise<UserPermissionDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserPermissionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserPermissionDto[]>(null as any);
    }

    /**
     * 
     * @param clientId (optional) 
     */
    getUserEffectivePermissions(userId: string, clientId: string | null | undefined): Promise<EffectivePermissionDto2[]> {
        let url_ = this.baseUrl + "/api/Permission/users/{userId}/effective-permissions?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (clientId !== undefined && clientId !== null)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUserEffectivePermissions(_response);
        });
    }

    protected processGetUserEffectivePermissions(response: Response): Promise<EffectivePermissionDto2[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EffectivePermissionDto2.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EffectivePermissionDto2[]>(null as any);
    }

    /**
     * 
     * @param clientId (optional) 
     * @param resourceId (optional) 
     * @param scope (optional) 
     */
    hasPermission(userId: string, clientId: string | null | undefined, resourceId: string | null | undefined, scope: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Permission/users/{userId}/has-permission?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (clientId !== undefined && clientId !== null)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&";
        if (resourceId !== undefined && resourceId !== null)
            url_ += "resourceId=" + encodeURIComponent("" + resourceId) + "&";
        if (scope !== undefined && scope !== null)
            url_ += "scope=" + encodeURIComponent("" + scope) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processHasPermission(_response);
        });
    }

    protected processHasPermission(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * 
     * @param clientId (optional) 
     */
    getGroupPermissions(groupId: string, clientId: string | null | undefined): Promise<GroupPermissionDto[]> {
        let url_ = this.baseUrl + "/api/Permission/groups/{groupId}/permissions?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (clientId !== undefined && clientId !== null)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetGroupPermissions(_response);
        });
    }

    protected processGetGroupPermissions(response: Response): Promise<GroupPermissionDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GroupPermissionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GroupPermissionDto[]>(null as any);
    }

    /**
     * 
     */
    setGroupPermission(groupId: string, dto: SetGroupPermissionDto): Promise<GroupPermissionDto> {
        let url_ = this.baseUrl + "/api/Permission/groups/{groupId}/permissions";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSetGroupPermission(_response);
        });
    }

    protected processSetGroupPermission(response: Response): Promise<GroupPermissionDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GroupPermissionDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GroupPermissionDto>(null as any);
    }

    /**
     * 
     * @param clientId (optional) 
     * @param resourceId (optional) 
     */
    removeGroupPermission(groupId: string, clientId: string | null | undefined, resourceId: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Permission/groups/{groupId}/permissions?";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (clientId !== undefined && clientId !== null)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&";
        if (resourceId !== undefined && resourceId !== null)
            url_ += "resourceId=" + encodeURIComponent("" + resourceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRemoveGroupPermission(_response);
        });
    }

    protected processRemoveGroupPermission(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 
     * @param clientId (optional) 
     */
    getResourceGroupPermissions(resourceId: string, clientId: string | null | undefined): Promise<GroupPermissionDto[]> {
        let url_ = this.baseUrl + "/api/Permission/resources/{resourceId}/group-permissions?";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (clientId !== undefined && clientId !== null)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetResourceGroupPermissions(_response);
        });
    }

    protected processGetResourceGroupPermissions(response: Response): Promise<GroupPermissionDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GroupPermissionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GroupPermissionDto[]>(null as any);
    }
}

export interface IPermissionQueryClient {

    /**
     * 
     * @param request 
     * @return 
     */
    queryPermissions(request: PermissionQueryRequest): Promise<PermissionQueryResponse>;

    /**
     * 
     * @param request 
     * @return  scope 
     */
    checkPermission(request: PermissionCheckRequest): Promise<{ [key: string]: ScopeCheckResultDto; }>;

    /**
     * 
     * @return API 
     */
    health(): Promise<any>;
}

export class PermissionQueryClient extends WebApiClientBase implements IPermissionQueryClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * 
     * @param request 
     * @return 
     */
    queryPermissions(request: PermissionQueryRequest): Promise<PermissionQueryResponse> {
        let url_ = this.baseUrl + "/api/prs/permissions/query";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processQueryPermissions(_response);
        });
    }

    protected processQueryPermissions(response: Response): Promise<PermissionQueryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionQueryResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = PermissionQueryErrorResponse.fromJS(resultData400);
            return throwException("\u8acb\u6c42\u53c3\u6578\u932f\u8aa4", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = PermissionQueryErrorResponse.fromJS(resultData401);
            return throwException("Client \u6191\u8b49\u6216 Token \u9a57\u8b49\u5931\u6557", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = PermissionQueryErrorResponse.fromJS(resultData404);
            return throwException("\u4f7f\u7528\u8005\u672a\u8a3b\u518a\u65bc\u6b0a\u9650\u7cfb\u7d71", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = PermissionQueryErrorResponse.fromJS(resultData500);
            return throwException("\u4f3a\u670d\u5668\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionQueryResponse>(null as any);
    }

    /**
     * 
     * @param request 
     * @return  scope 
     */
    checkPermission(request: PermissionCheckRequest): Promise<{ [key: string]: ScopeCheckResultDto; }> {
        let url_ = this.baseUrl + "/api/prs/permissions/check";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCheckPermission(_response);
        });
    }

    protected processCheckPermission(response: Response): Promise<{ [key: string]: ScopeCheckResultDto; }> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] ? ScopeCheckResultDto.fromJS(resultData200[key]) : new ScopeCheckResultDto();
                }
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData400) {
                result400 = {} as any;
                for (let key in resultData400) {
                    if (resultData400.hasOwnProperty(key))
                        (<any>result400)![key] = resultData400[key] ? ScopeCheckResultDto.fromJS(resultData400[key]) : new ScopeCheckResultDto();
                }
            }
            else {
                result400 = <any>null;
            }
            return throwException("\u8acb\u6c42\u53c3\u6578\u932f\u8aa4", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData401) {
                result401 = {} as any;
                for (let key in resultData401) {
                    if (resultData401.hasOwnProperty(key))
                        (<any>result401)![key] = resultData401[key] ? ScopeCheckResultDto.fromJS(resultData401[key]) : new ScopeCheckResultDto();
                }
            }
            else {
                result401 = <any>null;
            }
            return throwException("Client \u6191\u8b49\u6216 Token \u9a57\u8b49\u5931\u6557", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData404) {
                result404 = {} as any;
                for (let key in resultData404) {
                    if (resultData404.hasOwnProperty(key))
                        (<any>result404)![key] = resultData404[key] ? ScopeCheckResultDto.fromJS(resultData404[key]) : new ScopeCheckResultDto();
                }
            }
            else {
                result404 = <any>null;
            }
            return throwException("\u4f7f\u7528\u8005\u672a\u8a3b\u518a\u65bc\u6b0a\u9650\u7cfb\u7d71", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData500) {
                result500 = {} as any;
                for (let key in resultData500) {
                    if (resultData500.hasOwnProperty(key))
                        (<any>result500)![key] = resultData500[key] ? ScopeCheckResultDto.fromJS(resultData500[key]) : new ScopeCheckResultDto();
                }
            }
            else {
                result500 = <any>null;
            }
            return throwException("\u4f3a\u670d\u5668\u5167\u90e8\u932f\u8aa4", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: ScopeCheckResultDto; }>(null as any);
    }

    /**
     * 
     * @return API 
     */
    health(): Promise<any> {
        let url_ = this.baseUrl + "/api/prs/permissions/health";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processHealth(_response);
        });
    }

    protected processHealth(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }
}

export interface IPersistedGrantsClient {

    get(searchText: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<PersistedGrantSubjectsApiDto>;

    get2(id: string): Promise<PersistedGrantApiDto>;

    delete(id: string): Promise<FileResponse>;

    getBySubject(subjectId: string, page: number | undefined, pageSize: number | undefined): Promise<PersistedGrantsApiDto>;

    deleteBySubject(subjectId: string): Promise<FileResponse>;
}

export class PersistedGrantsClient extends WebApiClientBase implements IPersistedGrantsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    get(searchText: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<PersistedGrantSubjectsApiDto> {
        let url_ = this.baseUrl + "/api/PersistedGrants/Subjects?";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<PersistedGrantSubjectsApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PersistedGrantSubjectsApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PersistedGrantSubjectsApiDto>(null as any);
    }

    get2(id: string): Promise<PersistedGrantApiDto> {
        let url_ = this.baseUrl + "/api/PersistedGrants/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet2(_response);
        });
    }

    protected processGet2(response: Response): Promise<PersistedGrantApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PersistedGrantApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PersistedGrantApiDto>(null as any);
    }

    delete(id: string): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/PersistedGrants/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    getBySubject(subjectId: string, page: number | undefined, pageSize: number | undefined): Promise<PersistedGrantsApiDto> {
        let url_ = this.baseUrl + "/api/PersistedGrants/Subjects/{subjectId}?";
        if (subjectId === undefined || subjectId === null)
            throw new Error("The parameter 'subjectId' must be defined.");
        url_ = url_.replace("{subjectId}", encodeURIComponent("" + subjectId));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetBySubject(_response);
        });
    }

    protected processGetBySubject(response: Response): Promise<PersistedGrantsApiDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PersistedGrantsApiDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PersistedGrantsApiDto>(null as any);
    }

    deleteBySubject(subjectId: string): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/PersistedGrants/Subjects/{subjectId}";
        if (subjectId === undefined || subjectId === null)
            throw new Error("The parameter 'subjectId' must be defined.");
        url_ = url_.replace("{subjectId}", encodeURIComponent("" + subjectId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteBySubject(_response);
        });
    }

    protected processDeleteBySubject(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export interface IRoleManagementClient {

    /**
     * 
     */
    getRoles(): Promise<RoleWithCountDto[]>;

    /**
     * 
     */
    createRole(dto: CreateRoleDto): Promise<RoleWithCountDto>;

    /**
     * 
     */
    getRole(id: string): Promise<RoleWithCountDto>;

    /**
     * 
     */
    updateRole(id: string, dto: UpdateRoleDto): Promise<FileResponse>;

    /**
     * 
     */
    deleteRole(id: string): Promise<FileResponse>;

    /**
     * 
     */
    getRoleUsers(id: string): Promise<RoleUserDto[]>;

    /**
     * 
     */
    getRoleClaims(id: string): Promise<RoleClaimDto[]>;

    /**
     * 
     */
    addRoleClaim(id: string, dto: AddRoleClaimDto): Promise<FileResponse>;

    /**
     * 
     * @param claimType (optional) 
     * @param claimValue (optional) 
     */
    removeRoleClaim(id: string, claimType: string | null | undefined, claimValue: string | null | undefined): Promise<FileResponse>;
}

export class RoleManagementClient extends WebApiClientBase implements IRoleManagementClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * 
     */
    getRoles(): Promise<RoleWithCountDto[]> {
        let url_ = this.baseUrl + "/api/role-management";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRoles(_response);
        });
    }

    protected processGetRoles(response: Response): Promise<RoleWithCountDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RoleWithCountDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RoleWithCountDto[]>(null as any);
    }

    /**
     * 
     */
    createRole(dto: CreateRoleDto): Promise<RoleWithCountDto> {
        let url_ = this.baseUrl + "/api/role-management";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateRole(_response);
        });
    }

    protected processCreateRole(response: Response): Promise<RoleWithCountDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleWithCountDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RoleWithCountDto>(null as any);
    }

    /**
     * 
     */
    getRole(id: string): Promise<RoleWithCountDto> {
        let url_ = this.baseUrl + "/api/role-management/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRole(_response);
        });
    }

    protected processGetRole(response: Response): Promise<RoleWithCountDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleWithCountDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RoleWithCountDto>(null as any);
    }

    /**
     * 
     */
    updateRole(id: string, dto: UpdateRoleDto): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/role-management/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateRole(_response);
        });
    }

    protected processUpdateRole(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * 
     */
    deleteRole(id: string): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/role-management/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteRole(_response);
        });
    }

    protected processDeleteRole(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * 
     */
    getRoleUsers(id: string): Promise<RoleUserDto[]> {
        let url_ = this.baseUrl + "/api/role-management/{id}/users";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRoleUsers(_response);
        });
    }

    protected processGetRoleUsers(response: Response): Promise<RoleUserDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RoleUserDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RoleUserDto[]>(null as any);
    }

    /**
     * 
     */
    getRoleClaims(id: string): Promise<RoleClaimDto[]> {
        let url_ = this.baseUrl + "/api/role-management/{id}/claims";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRoleClaims(_response);
        });
    }

    protected processGetRoleClaims(response: Response): Promise<RoleClaimDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RoleClaimDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RoleClaimDto[]>(null as any);
    }

    /**
     * 
     */
    addRoleClaim(id: string, dto: AddRoleClaimDto): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/role-management/{id}/claims";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddRoleClaim(_response);
        });
    }

    protected processAddRoleClaim(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * 
     * @param claimType (optional) 
     * @param claimValue (optional) 
     */
    removeRoleClaim(id: string, claimType: string | null | undefined, claimValue: string | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/role-management/{id}/claims?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (claimType !== undefined && claimType !== null)
            url_ += "claimType=" + encodeURIComponent("" + claimType) + "&";
        if (claimValue !== undefined && claimValue !== null)
            url_ += "claimValue=" + encodeURIComponent("" + claimValue) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRemoveRoleClaim(_response);
        });
    }

    protected processRemoveRoleClaim(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export interface ITokenManagementClient {

    /**
     *  Token
     * @param page (optional)  1 
     * @param pageSize (optional) 
     * @param search (optional) 
     */
    getActiveTokens(page: number | undefined, pageSize: number | undefined, search: string | null | undefined): Promise<TokenListResponseOfActiveTokenDto>;

    /**
     *  Token
     * @param subjectId  ID
     * @param page (optional) 
     * @param pageSize (optional) 
     */
    getUserActiveTokens(subjectId: string, page: number | undefined, pageSize: number | undefined): Promise<TokenListResponseOfActiveTokenDto>;

    /**
     *  Token
     * @param clientId  ID
     * @param page (optional) 
     * @param pageSize (optional) 
     */
    getClientActiveTokens(clientId: string, page: number | undefined, pageSize: number | undefined): Promise<TokenListResponseOfActiveTokenDto>;

    /**
     *  Token
     * @param page (optional) 
     * @param pageSize (optional) 
     */
    getRevokedTokens(page: number | undefined, pageSize: number | undefined): Promise<TokenListResponseOfRevokedTokenDto>;

    /**
     *  Token 
     */
    getStatistics(): Promise<TokenStatistics>;

    /**
     *  Token 
     * @param jti JWT Token ID
     */
    checkTokenRevoked(jti: string): Promise<TokenCheckResponse>;

    /**
     *  Token JTI
     * @param request 
     */
    revokeToken(request: RevokeTokenRequest): Promise<RevokedTokenDto>;

    /**
     *  Token Grant Key
     * @param grantKey Grant Key
     * @param reason (optional) 
     */
    revokeByGrantKey(grantKey: string, reason: string | null | undefined): Promise<void>;

    /**
     *  Token
     * @param subjectId  ID
     * @param reason (optional) 
     */
    revokeUserTokens(subjectId: string, reason: string | null | undefined): Promise<RevokeAllResponse>;

    /**
     *  Token
     * @param clientId  ID
     * @param reason (optional) 
     */
    revokeClientTokens(clientId: string, reason: string | null | undefined): Promise<RevokeAllResponse>;

    /**
     * 
     * @param jti JWT Token ID
     */
    unrevokeToken(jti: string): Promise<void>;

    /**
     * 
     */
    cleanupExpired(): Promise<CleanupResponse>;
}

export class TokenManagementClient extends WebApiClientBase implements ITokenManagementClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     *  Token
     * @param page (optional)  1 
     * @param pageSize (optional) 
     * @param search (optional) 
     */
    getActiveTokens(page: number | undefined, pageSize: number | undefined, search: string | null | undefined): Promise<TokenListResponseOfActiveTokenDto> {
        let url_ = this.baseUrl + "/api/TokenManagement/active?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetActiveTokens(_response);
        });
    }

    protected processGetActiveTokens(response: Response): Promise<TokenListResponseOfActiveTokenDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenListResponseOfActiveTokenDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TokenListResponseOfActiveTokenDto>(null as any);
    }

    /**
     *  Token
     * @param subjectId  ID
     * @param page (optional) 
     * @param pageSize (optional) 
     */
    getUserActiveTokens(subjectId: string, page: number | undefined, pageSize: number | undefined): Promise<TokenListResponseOfActiveTokenDto> {
        let url_ = this.baseUrl + "/api/TokenManagement/active/user/{subjectId}?";
        if (subjectId === undefined || subjectId === null)
            throw new Error("The parameter 'subjectId' must be defined.");
        url_ = url_.replace("{subjectId}", encodeURIComponent("" + subjectId));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUserActiveTokens(_response);
        });
    }

    protected processGetUserActiveTokens(response: Response): Promise<TokenListResponseOfActiveTokenDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenListResponseOfActiveTokenDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TokenListResponseOfActiveTokenDto>(null as any);
    }

    /**
     *  Token
     * @param clientId  ID
     * @param page (optional) 
     * @param pageSize (optional) 
     */
    getClientActiveTokens(clientId: string, page: number | undefined, pageSize: number | undefined): Promise<TokenListResponseOfActiveTokenDto> {
        let url_ = this.baseUrl + "/api/TokenManagement/active/client/{clientId}?";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetClientActiveTokens(_response);
        });
    }

    protected processGetClientActiveTokens(response: Response): Promise<TokenListResponseOfActiveTokenDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenListResponseOfActiveTokenDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TokenListResponseOfActiveTokenDto>(null as any);
    }

    /**
     *  Token
     * @param page (optional) 
     * @param pageSize (optional) 
     */
    getRevokedTokens(page: number | undefined, pageSize: number | undefined): Promise<TokenListResponseOfRevokedTokenDto> {
        let url_ = this.baseUrl + "/api/TokenManagement/revoked?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRevokedTokens(_response);
        });
    }

    protected processGetRevokedTokens(response: Response): Promise<TokenListResponseOfRevokedTokenDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenListResponseOfRevokedTokenDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TokenListResponseOfRevokedTokenDto>(null as any);
    }

    /**
     *  Token 
     */
    getStatistics(): Promise<TokenStatistics> {
        let url_ = this.baseUrl + "/api/TokenManagement/statistics";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetStatistics(_response);
        });
    }

    protected processGetStatistics(response: Response): Promise<TokenStatistics> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenStatistics.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TokenStatistics>(null as any);
    }

    /**
     *  Token 
     * @param jti JWT Token ID
     */
    checkTokenRevoked(jti: string): Promise<TokenCheckResponse> {
        let url_ = this.baseUrl + "/api/TokenManagement/check/{jti}";
        if (jti === undefined || jti === null)
            throw new Error("The parameter 'jti' must be defined.");
        url_ = url_.replace("{jti}", encodeURIComponent("" + jti));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCheckTokenRevoked(_response);
        });
    }

    protected processCheckTokenRevoked(response: Response): Promise<TokenCheckResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenCheckResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TokenCheckResponse>(null as any);
    }

    /**
     *  Token JTI
     * @param request 
     */
    revokeToken(request: RevokeTokenRequest): Promise<RevokedTokenDto> {
        let url_ = this.baseUrl + "/api/TokenManagement/revoke";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRevokeToken(_response);
        });
    }

    protected processRevokeToken(response: Response): Promise<RevokedTokenDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RevokedTokenDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RevokedTokenDto>(null as any);
    }

    /**
     *  Token Grant Key
     * @param grantKey Grant Key
     * @param reason (optional) 
     */
    revokeByGrantKey(grantKey: string, reason: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/TokenManagement/revoke/grant/{grantKey}?";
        if (grantKey === undefined || grantKey === null)
            throw new Error("The parameter 'grantKey' must be defined.");
        url_ = url_.replace("{grantKey}", encodeURIComponent("" + grantKey));
        if (reason !== undefined && reason !== null)
            url_ += "reason=" + encodeURIComponent("" + reason) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRevokeByGrantKey(_response);
        });
    }

    protected processRevokeByGrantKey(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     *  Token
     * @param subjectId  ID
     * @param reason (optional) 
     */
    revokeUserTokens(subjectId: string, reason: string | null | undefined): Promise<RevokeAllResponse> {
        let url_ = this.baseUrl + "/api/TokenManagement/revoke/user/{subjectId}?";
        if (subjectId === undefined || subjectId === null)
            throw new Error("The parameter 'subjectId' must be defined.");
        url_ = url_.replace("{subjectId}", encodeURIComponent("" + subjectId));
        if (reason !== undefined && reason !== null)
            url_ += "reason=" + encodeURIComponent("" + reason) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRevokeUserTokens(_response);
        });
    }

    protected processRevokeUserTokens(response: Response): Promise<RevokeAllResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RevokeAllResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RevokeAllResponse>(null as any);
    }

    /**
     *  Token
     * @param clientId  ID
     * @param reason (optional) 
     */
    revokeClientTokens(clientId: string, reason: string | null | undefined): Promise<RevokeAllResponse> {
        let url_ = this.baseUrl + "/api/TokenManagement/revoke/client/{clientId}?";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (reason !== undefined && reason !== null)
            url_ += "reason=" + encodeURIComponent("" + reason) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRevokeClientTokens(_response);
        });
    }

    protected processRevokeClientTokens(response: Response): Promise<RevokeAllResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RevokeAllResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RevokeAllResponse>(null as any);
    }

    /**
     * 
     * @param jti JWT Token ID
     */
    unrevokeToken(jti: string): Promise<void> {
        let url_ = this.baseUrl + "/api/TokenManagement/revoke/{jti}";
        if (jti === undefined || jti === null)
            throw new Error("The parameter 'jti' must be defined.");
        url_ = url_.replace("{jti}", encodeURIComponent("" + jti));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUnrevokeToken(_response);
        });
    }

    protected processUnrevokeToken(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * 
     */
    cleanupExpired(): Promise<CleanupResponse> {
        let url_ = this.baseUrl + "/api/TokenManagement/cleanup";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCleanupExpired(_response);
        });
    }

    protected processCleanupExpired(response: Response): Promise<CleanupResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CleanupResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CleanupResponse>(null as any);
    }
}

export interface IUserManagementClient {

    /**
     * 
     * @param search (optional) 
     * @param isActive (optional) 
     * @param emailConfirmed (optional) 
     * @param roleId (optional) 
     * @param organizationId (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sortBy (optional) 
     * @param sortDirection (optional) 
     */
    getUsers(search: string | null | undefined, isActive: boolean | null | undefined, emailConfirmed: boolean | null | undefined, roleId: string | null | undefined, organizationId: string | null | undefined, page: number | undefined, pageSize: number | undefined, sortBy: string | null | undefined, sortDirection: string | null | undefined): Promise<PagedUserResultDto>;

    /**
     * 
     */
    createUser(dto: CreateUserDto): Promise<UserDetailDto>;

    /**
     * 
     */
    getUser(id: string): Promise<UserDetailDto>;

    /**
     * 
     */
    updateUser(id: string, dto: UpdateUserDetailDto): Promise<FileResponse>;

    /**
     * 
     */
    deleteUser(id: string): Promise<FileResponse>;

    /**
     * 
     */
    getUserClaims(id: string): Promise<UserClaimDto[]>;

    /**
     * 
     */
    addUserClaim(id: string, dto: AddUserClaimDto): Promise<UserClaimDto>;

    /**
     * 
     */
    deleteUserClaim(id: string, claimId: number): Promise<FileResponse>;

    /**
     * 
     */
    addRoleToUser(id: string, roleId: string): Promise<FileResponse>;

    /**
     * 
     */
    removeRoleFromUser(id: string, roleId: string): Promise<FileResponse>;

    /**
     * 
     */
    getStats(): Promise<UserStatsDto>;

    /**
     * 
     */
    activate(id: string): Promise<FileResponse>;

    /**
     * 
     */
    deactivate(id: string): Promise<FileResponse>;

    /**
     * 
     */
    unlock(id: string): Promise<FileResponse>;

    /**
     * 
     */
    resetPassword(id: string, dto: ResetPasswordDto): Promise<FileResponse>;

    /**
     * 
     */
    setUserRoles(id: string, dto: SetUserRolesDto): Promise<FileResponse>;

    /**
     * 
     */
    getUserRoles(id: string): Promise<UserRoleDto[]>;

    /**
     * 
     * @param search (optional) 
     * @param limit (optional) 
     */
    searchUsers(search: string | null | undefined, limit: number | undefined): Promise<UserBriefDto[]>;

    /**
     * 
     * @param username (optional) 
     * @param excludeId (optional) 
     */
    checkUsernameAvailable(username: string | null | undefined, excludeId: string | null | undefined): Promise<AvailabilityDto>;

    /**
     *  Email 
     * @param email (optional) 
     * @param excludeId (optional) 
     */
    checkEmailAvailable(email: string | null | undefined, excludeId: string | null | undefined): Promise<AvailabilityDto>;

    /**
     * 
     */
    bulkOperation(dto: BulkUserOperationDto): Promise<BulkOperationResultDto>;

    /**
     * 
     */
    getUserDetail(id: string): Promise<UserDetailDto>;

    /**
     * 
     */
    updateUserDetail(id: string, dto: UpdateUserDetailDto): Promise<FileResponse>;
}

export class UserManagementClient extends WebApiClientBase implements IUserManagementClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * 
     * @param search (optional) 
     * @param isActive (optional) 
     * @param emailConfirmed (optional) 
     * @param roleId (optional) 
     * @param organizationId (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sortBy (optional) 
     * @param sortDirection (optional) 
     */
    getUsers(search: string | null | undefined, isActive: boolean | null | undefined, emailConfirmed: boolean | null | undefined, roleId: string | null | undefined, organizationId: string | null | undefined, page: number | undefined, pageSize: number | undefined, sortBy: string | null | undefined, sortDirection: string | null | undefined): Promise<PagedUserResultDto> {
        let url_ = this.baseUrl + "/api/user-management?";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        if (emailConfirmed !== undefined && emailConfirmed !== null)
            url_ += "emailConfirmed=" + encodeURIComponent("" + emailConfirmed) + "&";
        if (roleId !== undefined && roleId !== null)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
        if (organizationId !== undefined && organizationId !== null)
            url_ += "organizationId=" + encodeURIComponent("" + organizationId) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "sortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUsers(_response);
        });
    }

    protected processGetUsers(response: Response): Promise<PagedUserResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedUserResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedUserResultDto>(null as any);
    }

    /**
     * 
     */
    createUser(dto: CreateUserDto): Promise<UserDetailDto> {
        let url_ = this.baseUrl + "/api/user-management";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateUser(_response);
        });
    }

    protected processCreateUser(response: Response): Promise<UserDetailDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDetailDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDetailDto>(null as any);
    }

    /**
     * 
     */
    getUser(id: string): Promise<UserDetailDto> {
        let url_ = this.baseUrl + "/api/user-management/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUser(_response);
        });
    }

    protected processGetUser(response: Response): Promise<UserDetailDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDetailDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDetailDto>(null as any);
    }

    /**
     * 
     */
    updateUser(id: string, dto: UpdateUserDetailDto): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/user-management/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateUser(_response);
        });
    }

    protected processUpdateUser(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * 
     */
    deleteUser(id: string): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/user-management/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteUser(_response);
        });
    }

    protected processDeleteUser(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * 
     */
    getUserClaims(id: string): Promise<UserClaimDto[]> {
        let url_ = this.baseUrl + "/api/user-management/{id}/claims";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUserClaims(_response);
        });
    }

    protected processGetUserClaims(response: Response): Promise<UserClaimDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserClaimDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserClaimDto[]>(null as any);
    }

    /**
     * 
     */
    addUserClaim(id: string, dto: AddUserClaimDto): Promise<UserClaimDto> {
        let url_ = this.baseUrl + "/api/user-management/{id}/claims";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddUserClaim(_response);
        });
    }

    protected processAddUserClaim(response: Response): Promise<UserClaimDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserClaimDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserClaimDto>(null as any);
    }

    /**
     * 
     */
    deleteUserClaim(id: string, claimId: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/user-management/{id}/claims/{claimId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (claimId === undefined || claimId === null)
            throw new Error("The parameter 'claimId' must be defined.");
        url_ = url_.replace("{claimId}", encodeURIComponent("" + claimId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteUserClaim(_response);
        });
    }

    protected processDeleteUserClaim(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * 
     */
    addRoleToUser(id: string, roleId: string): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/user-management/{id}/roles/{roleId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddRoleToUser(_response);
        });
    }

    protected processAddRoleToUser(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * 
     */
    removeRoleFromUser(id: string, roleId: string): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/user-management/{id}/roles/{roleId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRemoveRoleFromUser(_response);
        });
    }

    protected processRemoveRoleFromUser(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * 
     */
    getStats(): Promise<UserStatsDto> {
        let url_ = this.baseUrl + "/api/user-management/stats";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetStats(_response);
        });
    }

    protected processGetStats(response: Response): Promise<UserStatsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserStatsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserStatsDto>(null as any);
    }

    /**
     * 
     */
    activate(id: string): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/user-management/{id}/activate";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processActivate(_response);
        });
    }

    protected processActivate(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * 
     */
    deactivate(id: string): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/user-management/{id}/deactivate";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeactivate(_response);
        });
    }

    protected processDeactivate(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * 
     */
    unlock(id: string): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/user-management/{id}/unlock";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUnlock(_response);
        });
    }

    protected processUnlock(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * 
     */
    resetPassword(id: string, dto: ResetPasswordDto): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/user-management/{id}/reset-password";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processResetPassword(_response);
        });
    }

    protected processResetPassword(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * 
     */
    setUserRoles(id: string, dto: SetUserRolesDto): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/user-management/{id}/roles";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSetUserRoles(_response);
        });
    }

    protected processSetUserRoles(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * 
     */
    getUserRoles(id: string): Promise<UserRoleDto[]> {
        let url_ = this.baseUrl + "/api/user-management/{id}/roles";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUserRoles(_response);
        });
    }

    protected processGetUserRoles(response: Response): Promise<UserRoleDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserRoleDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserRoleDto[]>(null as any);
    }

    /**
     * 
     * @param search (optional) 
     * @param limit (optional) 
     */
    searchUsers(search: string | null | undefined, limit: number | undefined): Promise<UserBriefDto[]> {
        let url_ = this.baseUrl + "/api/user-management/search?";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchUsers(_response);
        });
    }

    protected processSearchUsers(response: Response): Promise<UserBriefDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserBriefDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserBriefDto[]>(null as any);
    }

    /**
     * 
     * @param username (optional) 
     * @param excludeId (optional) 
     */
    checkUsernameAvailable(username: string | null | undefined, excludeId: string | null | undefined): Promise<AvailabilityDto> {
        let url_ = this.baseUrl + "/api/user-management/check-username?";
        if (username !== undefined && username !== null)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        if (excludeId !== undefined && excludeId !== null)
            url_ += "excludeId=" + encodeURIComponent("" + excludeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCheckUsernameAvailable(_response);
        });
    }

    protected processCheckUsernameAvailable(response: Response): Promise<AvailabilityDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AvailabilityDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AvailabilityDto>(null as any);
    }

    /**
     *  Email 
     * @param email (optional) 
     * @param excludeId (optional) 
     */
    checkEmailAvailable(email: string | null | undefined, excludeId: string | null | undefined): Promise<AvailabilityDto> {
        let url_ = this.baseUrl + "/api/user-management/check-email?";
        if (email !== undefined && email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        if (excludeId !== undefined && excludeId !== null)
            url_ += "excludeId=" + encodeURIComponent("" + excludeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCheckEmailAvailable(_response);
        });
    }

    protected processCheckEmailAvailable(response: Response): Promise<AvailabilityDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AvailabilityDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AvailabilityDto>(null as any);
    }

    /**
     * 
     */
    bulkOperation(dto: BulkUserOperationDto): Promise<BulkOperationResultDto> {
        let url_ = this.baseUrl + "/api/user-management/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBulkOperation(_response);
        });
    }

    protected processBulkOperation(response: Response): Promise<BulkOperationResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkOperationResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BulkOperationResultDto>(null as any);
    }

    /**
     * 
     */
    getUserDetail(id: string): Promise<UserDetailDto> {
        let url_ = this.baseUrl + "/api/user-management/{id}/detail";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUserDetail(_response);
        });
    }

    protected processGetUserDetail(response: Response): Promise<UserDetailDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDetailDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDetailDto>(null as any);
    }

    /**
     * 
     */
    updateUserDetail(id: string, dto: UpdateUserDetailDto): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/user-management/{id}/detail";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateUserDetail(_response);
        });
    }

    protected processUpdateUserDetail(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export interface IRolesClient {

    get(id: string): Promise<IdentityRoleDto>;

    delete(id: string): Promise<FileResponse>;

    get2(searchText: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<IdentityRolesDto>;

    post(role: IdentityRoleDto): Promise<IdentityRoleDto>;

    put(role: IdentityRoleDto): Promise<FileResponse>;

    getRoleUsers(id: string, searchText: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<IdentityUsersDto>;

    getRoleClaims(id: string, page: number | undefined, pageSize: number | undefined): Promise<RoleClaimsApiDtoOfString>;

    deleteRoleClaims(id: string, claimId: number | undefined): Promise<FileResponse>;

    postRoleClaims(roleClaims: RoleClaimApiDtoOfString): Promise<FileResponse>;

    putRoleClaims(roleClaims: RoleClaimApiDtoOfString): Promise<FileResponse>;
}

export class RolesClient extends WebApiClientBase implements IRolesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    get(id: string): Promise<IdentityRoleDto> {
        let url_ = this.baseUrl + "/api/Roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<IdentityRoleDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityRoleDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityRoleDto>(null as any);
    }

    delete(id: string): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    get2(searchText: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<IdentityRolesDto> {
        let url_ = this.baseUrl + "/api/Roles?";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet2(_response);
        });
    }

    protected processGet2(response: Response): Promise<IdentityRolesDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityRolesDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityRolesDto>(null as any);
    }

    post(role: IdentityRoleDto): Promise<IdentityRoleDto> {
        let url_ = this.baseUrl + "/api/Roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(role);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<IdentityRoleDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = IdentityRoleDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityRoleDto>(null as any);
    }

    put(role: IdentityRoleDto): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(role);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    getRoleUsers(id: string, searchText: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<IdentityUsersDto> {
        let url_ = this.baseUrl + "/api/Roles/{id}/Users?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRoleUsers(_response);
        });
    }

    protected processGetRoleUsers(response: Response): Promise<IdentityUsersDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityUsersDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityUsersDto>(null as any);
    }

    getRoleClaims(id: string, page: number | undefined, pageSize: number | undefined): Promise<RoleClaimsApiDtoOfString> {
        let url_ = this.baseUrl + "/api/Roles/{id}/Claims?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRoleClaims(_response);
        });
    }

    protected processGetRoleClaims(response: Response): Promise<RoleClaimsApiDtoOfString> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleClaimsApiDtoOfString.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RoleClaimsApiDtoOfString>(null as any);
    }

    deleteRoleClaims(id: string, claimId: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Roles/{id}/Claims?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (claimId === null)
            throw new Error("The parameter 'claimId' cannot be null.");
        else if (claimId !== undefined)
            url_ += "claimId=" + encodeURIComponent("" + claimId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteRoleClaims(_response);
        });
    }

    protected processDeleteRoleClaims(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    postRoleClaims(roleClaims: RoleClaimApiDtoOfString): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Roles/Claims";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(roleClaims);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostRoleClaims(_response);
        });
    }

    protected processPostRoleClaims(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    putRoleClaims(roleClaims: RoleClaimApiDtoOfString): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Roles/Claims";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(roleClaims);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPutRoleClaims(_response);
        });
    }

    protected processPutRoleClaims(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export interface IUsersClient {

    get(id: string): Promise<IdentityUserDto>;

    delete(id: string): Promise<FileResponse>;

    get2(searchText: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<IdentityUsersDto>;

    post(user: IdentityUserDto): Promise<IdentityUserDto>;

    put(user: IdentityUserDto): Promise<FileResponse>;

    getUserRoles(id: string, page: number | undefined, pageSize: number | undefined): Promise<UserRolesApiDtoOfIdentityRoleDto>;

    postUserRoles(role: UserRoleApiDtoOfString): Promise<FileResponse>;

    deleteUserRoles(role: UserRoleApiDtoOfString): Promise<FileResponse>;

    getUserClaims(id: string, page: number | undefined, pageSize: number | undefined): Promise<UserClaimsApiDtoOfString>;

    deleteUserClaims(id: string, claimId: number | undefined): Promise<FileResponse>;

    postUserClaims(claim: UserClaimApiDtoOfString): Promise<FileResponse>;

    putUserClaims(claim: UserClaimApiDtoOfString): Promise<FileResponse>;

    getUserProviders(id: string): Promise<UserProvidersApiDtoOfString>;

    deleteUserProviders(provider: UserProviderDeleteApiDtoOfString): Promise<FileResponse>;

    postChangePassword(password: UserChangePasswordApiDtoOfString): Promise<FileResponse>;

    getRoleClaims(id: string, claimSearchText: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<RoleClaimsApiDtoOfString>;

    getClaimUsers(claimType: string, claimValue: string, page: number | undefined, pageSize: number | undefined): Promise<IdentityUsersDto>;

    getClaimUsers2(claimType: string, page: number | undefined, pageSize: number | undefined): Promise<IdentityUsersDto>;
}

export class UsersClient extends WebApiClientBase implements IUsersClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    get(id: string): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/api/Users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<IdentityUserDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityUserDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityUserDto>(null as any);
    }

    delete(id: string): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    get2(searchText: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<IdentityUsersDto> {
        let url_ = this.baseUrl + "/api/Users?";
        if (searchText !== undefined && searchText !== null)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet2(_response);
        });
    }

    protected processGet2(response: Response): Promise<IdentityUsersDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityUsersDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityUsersDto>(null as any);
    }

    post(user: IdentityUserDto): Promise<IdentityUserDto> {
        let url_ = this.baseUrl + "/api/Users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(user);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<IdentityUserDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = IdentityUserDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityUserDto>(null as any);
    }

    put(user: IdentityUserDto): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(user);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    getUserRoles(id: string, page: number | undefined, pageSize: number | undefined): Promise<UserRolesApiDtoOfIdentityRoleDto> {
        let url_ = this.baseUrl + "/api/Users/{id}/Roles?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUserRoles(_response);
        });
    }

    protected processGetUserRoles(response: Response): Promise<UserRolesApiDtoOfIdentityRoleDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserRolesApiDtoOfIdentityRoleDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserRolesApiDtoOfIdentityRoleDto>(null as any);
    }

    postUserRoles(role: UserRoleApiDtoOfString): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Users/Roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(role);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostUserRoles(_response);
        });
    }

    protected processPostUserRoles(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    deleteUserRoles(role: UserRoleApiDtoOfString): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Users/Roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(role);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteUserRoles(_response);
        });
    }

    protected processDeleteUserRoles(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    getUserClaims(id: string, page: number | undefined, pageSize: number | undefined): Promise<UserClaimsApiDtoOfString> {
        let url_ = this.baseUrl + "/api/Users/{id}/Claims?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUserClaims(_response);
        });
    }

    protected processGetUserClaims(response: Response): Promise<UserClaimsApiDtoOfString> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserClaimsApiDtoOfString.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserClaimsApiDtoOfString>(null as any);
    }

    deleteUserClaims(id: string, claimId: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Users/{id}/Claims?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (claimId === null)
            throw new Error("The parameter 'claimId' cannot be null.");
        else if (claimId !== undefined)
            url_ += "claimId=" + encodeURIComponent("" + claimId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteUserClaims(_response);
        });
    }

    protected processDeleteUserClaims(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    postUserClaims(claim: UserClaimApiDtoOfString): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Users/Claims";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(claim);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostUserClaims(_response);
        });
    }

    protected processPostUserClaims(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    putUserClaims(claim: UserClaimApiDtoOfString): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Users/Claims";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(claim);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPutUserClaims(_response);
        });
    }

    protected processPutUserClaims(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    getUserProviders(id: string): Promise<UserProvidersApiDtoOfString> {
        let url_ = this.baseUrl + "/api/Users/{id}/Providers";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUserProviders(_response);
        });
    }

    protected processGetUserProviders(response: Response): Promise<UserProvidersApiDtoOfString> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProvidersApiDtoOfString.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserProvidersApiDtoOfString>(null as any);
    }

    deleteUserProviders(provider: UserProviderDeleteApiDtoOfString): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Users/Providers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(provider);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteUserProviders(_response);
        });
    }

    protected processDeleteUserProviders(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    postChangePassword(password: UserChangePasswordApiDtoOfString): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Users/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(password);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPostChangePassword(_response);
        });
    }

    protected processPostChangePassword(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    getRoleClaims(id: string, claimSearchText: string | null | undefined, page: number | undefined, pageSize: number | undefined): Promise<RoleClaimsApiDtoOfString> {
        let url_ = this.baseUrl + "/api/Users/{id}/RoleClaims?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (claimSearchText !== undefined && claimSearchText !== null)
            url_ += "claimSearchText=" + encodeURIComponent("" + claimSearchText) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRoleClaims(_response);
        });
    }

    protected processGetRoleClaims(response: Response): Promise<RoleClaimsApiDtoOfString> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleClaimsApiDtoOfString.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RoleClaimsApiDtoOfString>(null as any);
    }

    getClaimUsers(claimType: string, claimValue: string, page: number | undefined, pageSize: number | undefined): Promise<IdentityUsersDto> {
        let url_ = this.baseUrl + "/api/Users/ClaimType/{claimType}/ClaimValue/{claimValue}?";
        if (claimType === undefined || claimType === null)
            throw new Error("The parameter 'claimType' must be defined.");
        url_ = url_.replace("{claimType}", encodeURIComponent("" + claimType));
        if (claimValue === undefined || claimValue === null)
            throw new Error("The parameter 'claimValue' must be defined.");
        url_ = url_.replace("{claimValue}", encodeURIComponent("" + claimValue));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetClaimUsers(_response);
        });
    }

    protected processGetClaimUsers(response: Response): Promise<IdentityUsersDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityUsersDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityUsersDto>(null as any);
    }

    getClaimUsers2(claimType: string, page: number | undefined, pageSize: number | undefined): Promise<IdentityUsersDto> {
        let url_ = this.baseUrl + "/api/Users/ClaimType/{claimType}?";
        if (claimType === undefined || claimType === null)
            throw new Error("The parameter 'claimType' must be defined.");
        url_ = url_.replace("{claimType}", encodeURIComponent("" + claimType));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetClaimUsers2(_response);
        });
    }

    protected processGetClaimUsers2(response: Response): Promise<IdentityUsersDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityUsersDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityUsersDto>(null as any);
    }
}

export class ApiResourcesApiDto implements IApiResourcesApiDto {
    pageSize!: number;
    totalCount!: number;
    apiResources!: ApiResourceApiDto[] | undefined;

    constructor(data?: IApiResourcesApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["apiResources"])) {
                this.apiResources = [] as any;
                for (let item of _data["apiResources"])
                    this.apiResources!.push(ApiResourceApiDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApiResourcesApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResourcesApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.apiResources)) {
            data["apiResources"] = [];
            for (let item of this.apiResources)
                data["apiResources"].push(item.toJSON());
        }
        return data;
    }
}

export interface IApiResourcesApiDto {
    pageSize: number;
    totalCount: number;
    apiResources: ApiResourceApiDto[] | undefined;
}

export class ApiResourceApiDto implements IApiResourceApiDto {
    id!: number;
    name!: string;
    displayName!: string | undefined;
    description!: string | undefined;
    enabled!: boolean;
    showInDiscoveryDocument!: boolean;
    requireResourceIndicator!: boolean;
    userClaims!: string[] | undefined;
    allowedAccessTokenSigningAlgorithms!: string[] | undefined;
    scopes!: string[] | undefined;

    constructor(data?: IApiResourceApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.enabled = _data["enabled"];
            this.showInDiscoveryDocument = _data["showInDiscoveryDocument"];
            this.requireResourceIndicator = _data["requireResourceIndicator"];
            if (Array.isArray(_data["userClaims"])) {
                this.userClaims = [] as any;
                for (let item of _data["userClaims"])
                    this.userClaims!.push(item);
            }
            if (Array.isArray(_data["allowedAccessTokenSigningAlgorithms"])) {
                this.allowedAccessTokenSigningAlgorithms = [] as any;
                for (let item of _data["allowedAccessTokenSigningAlgorithms"])
                    this.allowedAccessTokenSigningAlgorithms!.push(item);
            }
            if (Array.isArray(_data["scopes"])) {
                this.scopes = [] as any;
                for (let item of _data["scopes"])
                    this.scopes!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResourceApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResourceApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["enabled"] = this.enabled;
        data["showInDiscoveryDocument"] = this.showInDiscoveryDocument;
        data["requireResourceIndicator"] = this.requireResourceIndicator;
        if (Array.isArray(this.userClaims)) {
            data["userClaims"] = [];
            for (let item of this.userClaims)
                data["userClaims"].push(item);
        }
        if (Array.isArray(this.allowedAccessTokenSigningAlgorithms)) {
            data["allowedAccessTokenSigningAlgorithms"] = [];
            for (let item of this.allowedAccessTokenSigningAlgorithms)
                data["allowedAccessTokenSigningAlgorithms"].push(item);
        }
        if (Array.isArray(this.scopes)) {
            data["scopes"] = [];
            for (let item of this.scopes)
                data["scopes"].push(item);
        }
        return data;
    }
}

export interface IApiResourceApiDto {
    id: number;
    name: string;
    displayName: string | undefined;
    description: string | undefined;
    enabled: boolean;
    showInDiscoveryDocument: boolean;
    requireResourceIndicator: boolean;
    userClaims: string[] | undefined;
    allowedAccessTokenSigningAlgorithms: string[] | undefined;
    scopes: string[] | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type!: string | undefined;
    title!: string | undefined;
    status!: number | undefined;
    detail!: string | undefined;
    instance!: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type: string | undefined;
    title: string | undefined;
    status: number | undefined;
    detail: string | undefined;
    instance: string | undefined;

    [key: string]: any;
}

export class ApiSecretsApiDto implements IApiSecretsApiDto {
    totalCount!: number;
    pageSize!: number;
    apiSecrets!: ApiSecretApiDto[] | undefined;

    constructor(data?: IApiSecretsApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["apiSecrets"])) {
                this.apiSecrets = [] as any;
                for (let item of _data["apiSecrets"])
                    this.apiSecrets!.push(ApiSecretApiDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApiSecretsApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiSecretsApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.apiSecrets)) {
            data["apiSecrets"] = [];
            for (let item of this.apiSecrets)
                data["apiSecrets"].push(item.toJSON());
        }
        return data;
    }
}

export interface IApiSecretsApiDto {
    totalCount: number;
    pageSize: number;
    apiSecrets: ApiSecretApiDto[] | undefined;
}

export class ApiSecretApiDto implements IApiSecretApiDto {
    type!: string;
    id!: number;
    description!: string | undefined;
    value!: string;
    hashType!: string | undefined;
    expiration!: Date | undefined;
    created!: Date;

    constructor(data?: IApiSecretApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.id = _data["id"];
            this.description = _data["description"];
            this.value = _data["value"];
            this.hashType = _data["hashType"];
            this.expiration = _data["expiration"] ? new Date(_data["expiration"].toString()) : <any>undefined;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ApiSecretApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiSecretApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["id"] = this.id;
        data["description"] = this.description;
        data["value"] = this.value;
        data["hashType"] = this.hashType;
        data["expiration"] = this.expiration ? this.expiration.toISOString() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data;
    }
}

export interface IApiSecretApiDto {
    type: string;
    id: number;
    description: string | undefined;
    value: string;
    hashType: string | undefined;
    expiration: Date | undefined;
    created: Date;
}

export class ApiResourcePropertiesApiDto implements IApiResourcePropertiesApiDto {
    apiResourceProperties!: ApiResourcePropertyApiDto[] | undefined;
    totalCount!: number;
    pageSize!: number;

    constructor(data?: IApiResourcePropertiesApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["apiResourceProperties"])) {
                this.apiResourceProperties = [] as any;
                for (let item of _data["apiResourceProperties"])
                    this.apiResourceProperties!.push(ApiResourcePropertyApiDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): ApiResourcePropertiesApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResourcePropertiesApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.apiResourceProperties)) {
            data["apiResourceProperties"] = [];
            for (let item of this.apiResourceProperties)
                data["apiResourceProperties"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IApiResourcePropertiesApiDto {
    apiResourceProperties: ApiResourcePropertyApiDto[] | undefined;
    totalCount: number;
    pageSize: number;
}

export class ApiResourcePropertyApiDto implements IApiResourcePropertyApiDto {
    id!: number;
    key!: string | undefined;
    value!: string | undefined;

    constructor(data?: IApiResourcePropertyApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ApiResourcePropertyApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResourcePropertyApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IApiResourcePropertyApiDto {
    id: number;
    key: string | undefined;
    value: string | undefined;
}

export class ApiScopesApiDto implements IApiScopesApiDto {
    pageSize!: number;
    totalCount!: number;
    scopes!: ApiScopeApiDto[] | undefined;

    constructor(data?: IApiScopesApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["scopes"])) {
                this.scopes = [] as any;
                for (let item of _data["scopes"])
                    this.scopes!.push(ApiScopeApiDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApiScopesApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiScopesApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.scopes)) {
            data["scopes"] = [];
            for (let item of this.scopes)
                data["scopes"].push(item.toJSON());
        }
        return data;
    }
}

export interface IApiScopesApiDto {
    pageSize: number;
    totalCount: number;
    scopes: ApiScopeApiDto[] | undefined;
}

export class ApiScopeApiDto implements IApiScopeApiDto {
    showInDiscoveryDocument!: boolean;
    id!: number;
    name!: string;
    displayName!: string | undefined;
    description!: string | undefined;
    required!: boolean;
    emphasize!: boolean;
    enabled!: boolean;
    userClaims!: string[] | undefined;
    apiScopeProperties!: ApiScopePropertyApiDto[] | undefined;

    constructor(data?: IApiScopeApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.showInDiscoveryDocument = _data["showInDiscoveryDocument"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.required = _data["required"];
            this.emphasize = _data["emphasize"];
            this.enabled = _data["enabled"];
            if (Array.isArray(_data["userClaims"])) {
                this.userClaims = [] as any;
                for (let item of _data["userClaims"])
                    this.userClaims!.push(item);
            }
            if (Array.isArray(_data["apiScopeProperties"])) {
                this.apiScopeProperties = [] as any;
                for (let item of _data["apiScopeProperties"])
                    this.apiScopeProperties!.push(ApiScopePropertyApiDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApiScopeApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiScopeApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["showInDiscoveryDocument"] = this.showInDiscoveryDocument;
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["required"] = this.required;
        data["emphasize"] = this.emphasize;
        data["enabled"] = this.enabled;
        if (Array.isArray(this.userClaims)) {
            data["userClaims"] = [];
            for (let item of this.userClaims)
                data["userClaims"].push(item);
        }
        if (Array.isArray(this.apiScopeProperties)) {
            data["apiScopeProperties"] = [];
            for (let item of this.apiScopeProperties)
                data["apiScopeProperties"].push(item.toJSON());
        }
        return data;
    }
}

export interface IApiScopeApiDto {
    showInDiscoveryDocument: boolean;
    id: number;
    name: string;
    displayName: string | undefined;
    description: string | undefined;
    required: boolean;
    emphasize: boolean;
    enabled: boolean;
    userClaims: string[] | undefined;
    apiScopeProperties: ApiScopePropertyApiDto[] | undefined;
}

export class ApiScopePropertyApiDto implements IApiScopePropertyApiDto {
    id!: number;
    key!: string | undefined;
    value!: string | undefined;

    constructor(data?: IApiScopePropertyApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ApiScopePropertyApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiScopePropertyApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IApiScopePropertyApiDto {
    id: number;
    key: string | undefined;
    value: string | undefined;
}

export class ApiScopePropertiesApiDto implements IApiScopePropertiesApiDto {
    apiScopeProperties!: ApiScopePropertyApiDto[] | undefined;
    totalCount!: number;
    pageSize!: number;

    constructor(data?: IApiScopePropertiesApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["apiScopeProperties"])) {
                this.apiScopeProperties = [] as any;
                for (let item of _data["apiScopeProperties"])
                    this.apiScopeProperties!.push(ApiScopePropertyApiDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): ApiScopePropertiesApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiScopePropertiesApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.apiScopeProperties)) {
            data["apiScopeProperties"] = [];
            for (let item of this.apiScopeProperties)
                data["apiScopeProperties"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IApiScopePropertiesApiDto {
    apiScopeProperties: ApiScopePropertyApiDto[] | undefined;
    totalCount: number;
    pageSize: number;
}

export class ApiScopeDto implements IApiScopeDto {
    showInDiscoveryDocument!: boolean;
    id!: number;
    name!: string;
    displayName!: string | undefined;
    description!: string | undefined;
    required!: boolean;
    emphasize!: boolean;
    userClaims!: string[] | undefined;
    userClaimsItems!: string | undefined;
    enabled!: boolean;
    apiScopeProperties!: ApiScopePropertyDto[] | undefined;

    constructor(data?: IApiScopeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.showInDiscoveryDocument = _data["showInDiscoveryDocument"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.required = _data["required"];
            this.emphasize = _data["emphasize"];
            if (Array.isArray(_data["userClaims"])) {
                this.userClaims = [] as any;
                for (let item of _data["userClaims"])
                    this.userClaims!.push(item);
            }
            this.userClaimsItems = _data["userClaimsItems"];
            this.enabled = _data["enabled"];
            if (Array.isArray(_data["apiScopeProperties"])) {
                this.apiScopeProperties = [] as any;
                for (let item of _data["apiScopeProperties"])
                    this.apiScopeProperties!.push(ApiScopePropertyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApiScopeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiScopeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["showInDiscoveryDocument"] = this.showInDiscoveryDocument;
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["required"] = this.required;
        data["emphasize"] = this.emphasize;
        if (Array.isArray(this.userClaims)) {
            data["userClaims"] = [];
            for (let item of this.userClaims)
                data["userClaims"].push(item);
        }
        data["userClaimsItems"] = this.userClaimsItems;
        data["enabled"] = this.enabled;
        if (Array.isArray(this.apiScopeProperties)) {
            data["apiScopeProperties"] = [];
            for (let item of this.apiScopeProperties)
                data["apiScopeProperties"].push(item.toJSON());
        }
        return data;
    }
}

export interface IApiScopeDto {
    showInDiscoveryDocument: boolean;
    id: number;
    name: string;
    displayName: string | undefined;
    description: string | undefined;
    required: boolean;
    emphasize: boolean;
    userClaims: string[] | undefined;
    userClaimsItems: string | undefined;
    enabled: boolean;
    apiScopeProperties: ApiScopePropertyDto[] | undefined;
}

export class ApiScopePropertyDto implements IApiScopePropertyDto {
    id!: number;
    key!: string | undefined;
    value!: string | undefined;

    constructor(data?: IApiScopePropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ApiScopePropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiScopePropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IApiScopePropertyDto {
    id: number;
    key: string | undefined;
    value: string | undefined;
}

export class ClientsApiDto implements IClientsApiDto {
    clients!: ClientApiDto[] | undefined;
    totalCount!: number;
    pageSize!: number;

    constructor(data?: IClientsApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["clients"])) {
                this.clients = [] as any;
                for (let item of _data["clients"])
                    this.clients!.push(ClientApiDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): ClientsApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientsApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.clients)) {
            data["clients"] = [];
            for (let item of this.clients)
                data["clients"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IClientsApiDto {
    clients: ClientApiDto[] | undefined;
    totalCount: number;
    pageSize: number;
}

export class ClientApiDto implements IClientApiDto {
    absoluteRefreshTokenLifetime!: number;
    accessTokenLifetime!: number;
    consentLifetime!: number | undefined;
    accessTokenType!: number;
    allowAccessTokensViaBrowser!: boolean;
    allowOfflineAccess!: boolean;
    allowPlainTextPkce!: boolean;
    allowRememberConsent!: boolean;
    alwaysIncludeUserClaimsInIdToken!: boolean;
    alwaysSendClientClaims!: boolean;
    authorizationCodeLifetime!: number;
    frontChannelLogoutUri!: string | undefined;
    frontChannelLogoutSessionRequired!: boolean;
    backChannelLogoutUri!: string | undefined;
    backChannelLogoutSessionRequired!: boolean;
    clientId!: string;
    clientName!: string;
    clientUri!: string | undefined;
    description!: string | undefined;
    enabled!: boolean;
    enableLocalLogin!: boolean;
    id!: number;
    identityTokenLifetime!: number;
    includeJwtId!: boolean;
    logoUri!: string | undefined;
    clientClaimsPrefix!: string | undefined;
    pairWiseSubjectSalt!: string | undefined;
    protocolType!: string | undefined;
    refreshTokenExpiration!: number;
    refreshTokenUsage!: number;
    slidingRefreshTokenLifetime!: number;
    requireClientSecret!: boolean;
    requireConsent!: boolean;
    requirePkce!: boolean;
    updateAccessTokenClaimsOnRefresh!: boolean;
    postLogoutRedirectUris!: string[] | undefined;
    identityProviderRestrictions!: string[] | undefined;
    redirectUris!: string[] | undefined;
    allowedCorsOrigins!: string[] | undefined;
    allowedGrantTypes!: string[] | undefined;
    allowedScopes!: string[] | undefined;
    claims!: ClientClaimApiDto[] | undefined;
    properties!: ClientPropertyApiDto[] | undefined;
    updated!: Date | undefined;
    lastAccessed!: Date | undefined;
    userSsoLifetime!: number | undefined;
    userCodeType!: string | undefined;
    deviceCodeLifetime!: number;
    requireRequestObject!: boolean;
    cibaLifetime!: number | undefined;
    pollingInterval!: number | undefined;
    coordinateLifetimeWithUserSession!: boolean;
    requireDPoP!: boolean;
    dPoPValidationMode!: number;
    dPoPClockSkew!: string;
    pushedAuthorizationLifetime!: number | undefined;
    requirePushedAuthorization!: boolean;
    initiateLoginUri!: string | undefined;
    allowedIdentityTokenSigningAlgorithms!: string[] | undefined;
    nonEditable!: boolean;

    constructor(data?: IClientApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.absoluteRefreshTokenLifetime = _data["absoluteRefreshTokenLifetime"];
            this.accessTokenLifetime = _data["accessTokenLifetime"];
            this.consentLifetime = _data["consentLifetime"];
            this.accessTokenType = _data["accessTokenType"];
            this.allowAccessTokensViaBrowser = _data["allowAccessTokensViaBrowser"];
            this.allowOfflineAccess = _data["allowOfflineAccess"];
            this.allowPlainTextPkce = _data["allowPlainTextPkce"];
            this.allowRememberConsent = _data["allowRememberConsent"];
            this.alwaysIncludeUserClaimsInIdToken = _data["alwaysIncludeUserClaimsInIdToken"];
            this.alwaysSendClientClaims = _data["alwaysSendClientClaims"];
            this.authorizationCodeLifetime = _data["authorizationCodeLifetime"];
            this.frontChannelLogoutUri = _data["frontChannelLogoutUri"];
            this.frontChannelLogoutSessionRequired = _data["frontChannelLogoutSessionRequired"];
            this.backChannelLogoutUri = _data["backChannelLogoutUri"];
            this.backChannelLogoutSessionRequired = _data["backChannelLogoutSessionRequired"];
            this.clientId = _data["clientId"];
            this.clientName = _data["clientName"];
            this.clientUri = _data["clientUri"];
            this.description = _data["description"];
            this.enabled = _data["enabled"];
            this.enableLocalLogin = _data["enableLocalLogin"];
            this.id = _data["id"];
            this.identityTokenLifetime = _data["identityTokenLifetime"];
            this.includeJwtId = _data["includeJwtId"];
            this.logoUri = _data["logoUri"];
            this.clientClaimsPrefix = _data["clientClaimsPrefix"];
            this.pairWiseSubjectSalt = _data["pairWiseSubjectSalt"];
            this.protocolType = _data["protocolType"];
            this.refreshTokenExpiration = _data["refreshTokenExpiration"];
            this.refreshTokenUsage = _data["refreshTokenUsage"];
            this.slidingRefreshTokenLifetime = _data["slidingRefreshTokenLifetime"];
            this.requireClientSecret = _data["requireClientSecret"];
            this.requireConsent = _data["requireConsent"];
            this.requirePkce = _data["requirePkce"];
            this.updateAccessTokenClaimsOnRefresh = _data["updateAccessTokenClaimsOnRefresh"];
            if (Array.isArray(_data["postLogoutRedirectUris"])) {
                this.postLogoutRedirectUris = [] as any;
                for (let item of _data["postLogoutRedirectUris"])
                    this.postLogoutRedirectUris!.push(item);
            }
            if (Array.isArray(_data["identityProviderRestrictions"])) {
                this.identityProviderRestrictions = [] as any;
                for (let item of _data["identityProviderRestrictions"])
                    this.identityProviderRestrictions!.push(item);
            }
            if (Array.isArray(_data["redirectUris"])) {
                this.redirectUris = [] as any;
                for (let item of _data["redirectUris"])
                    this.redirectUris!.push(item);
            }
            if (Array.isArray(_data["allowedCorsOrigins"])) {
                this.allowedCorsOrigins = [] as any;
                for (let item of _data["allowedCorsOrigins"])
                    this.allowedCorsOrigins!.push(item);
            }
            if (Array.isArray(_data["allowedGrantTypes"])) {
                this.allowedGrantTypes = [] as any;
                for (let item of _data["allowedGrantTypes"])
                    this.allowedGrantTypes!.push(item);
            }
            if (Array.isArray(_data["allowedScopes"])) {
                this.allowedScopes = [] as any;
                for (let item of _data["allowedScopes"])
                    this.allowedScopes!.push(item);
            }
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(ClientClaimApiDto.fromJS(item));
            }
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(ClientPropertyApiDto.fromJS(item));
            }
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
            this.lastAccessed = _data["lastAccessed"] ? new Date(_data["lastAccessed"].toString()) : <any>undefined;
            this.userSsoLifetime = _data["userSsoLifetime"];
            this.userCodeType = _data["userCodeType"];
            this.deviceCodeLifetime = _data["deviceCodeLifetime"];
            this.requireRequestObject = _data["requireRequestObject"];
            this.cibaLifetime = _data["cibaLifetime"];
            this.pollingInterval = _data["pollingInterval"];
            this.coordinateLifetimeWithUserSession = _data["coordinateLifetimeWithUserSession"];
            this.requireDPoP = _data["requireDPoP"];
            this.dPoPValidationMode = _data["dPoPValidationMode"];
            this.dPoPClockSkew = _data["dPoPClockSkew"];
            this.pushedAuthorizationLifetime = _data["pushedAuthorizationLifetime"];
            this.requirePushedAuthorization = _data["requirePushedAuthorization"];
            this.initiateLoginUri = _data["initiateLoginUri"];
            if (Array.isArray(_data["allowedIdentityTokenSigningAlgorithms"])) {
                this.allowedIdentityTokenSigningAlgorithms = [] as any;
                for (let item of _data["allowedIdentityTokenSigningAlgorithms"])
                    this.allowedIdentityTokenSigningAlgorithms!.push(item);
            }
            this.nonEditable = _data["nonEditable"];
        }
    }

    static fromJS(data: any): ClientApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["absoluteRefreshTokenLifetime"] = this.absoluteRefreshTokenLifetime;
        data["accessTokenLifetime"] = this.accessTokenLifetime;
        data["consentLifetime"] = this.consentLifetime;
        data["accessTokenType"] = this.accessTokenType;
        data["allowAccessTokensViaBrowser"] = this.allowAccessTokensViaBrowser;
        data["allowOfflineAccess"] = this.allowOfflineAccess;
        data["allowPlainTextPkce"] = this.allowPlainTextPkce;
        data["allowRememberConsent"] = this.allowRememberConsent;
        data["alwaysIncludeUserClaimsInIdToken"] = this.alwaysIncludeUserClaimsInIdToken;
        data["alwaysSendClientClaims"] = this.alwaysSendClientClaims;
        data["authorizationCodeLifetime"] = this.authorizationCodeLifetime;
        data["frontChannelLogoutUri"] = this.frontChannelLogoutUri;
        data["frontChannelLogoutSessionRequired"] = this.frontChannelLogoutSessionRequired;
        data["backChannelLogoutUri"] = this.backChannelLogoutUri;
        data["backChannelLogoutSessionRequired"] = this.backChannelLogoutSessionRequired;
        data["clientId"] = this.clientId;
        data["clientName"] = this.clientName;
        data["clientUri"] = this.clientUri;
        data["description"] = this.description;
        data["enabled"] = this.enabled;
        data["enableLocalLogin"] = this.enableLocalLogin;
        data["id"] = this.id;
        data["identityTokenLifetime"] = this.identityTokenLifetime;
        data["includeJwtId"] = this.includeJwtId;
        data["logoUri"] = this.logoUri;
        data["clientClaimsPrefix"] = this.clientClaimsPrefix;
        data["pairWiseSubjectSalt"] = this.pairWiseSubjectSalt;
        data["protocolType"] = this.protocolType;
        data["refreshTokenExpiration"] = this.refreshTokenExpiration;
        data["refreshTokenUsage"] = this.refreshTokenUsage;
        data["slidingRefreshTokenLifetime"] = this.slidingRefreshTokenLifetime;
        data["requireClientSecret"] = this.requireClientSecret;
        data["requireConsent"] = this.requireConsent;
        data["requirePkce"] = this.requirePkce;
        data["updateAccessTokenClaimsOnRefresh"] = this.updateAccessTokenClaimsOnRefresh;
        if (Array.isArray(this.postLogoutRedirectUris)) {
            data["postLogoutRedirectUris"] = [];
            for (let item of this.postLogoutRedirectUris)
                data["postLogoutRedirectUris"].push(item);
        }
        if (Array.isArray(this.identityProviderRestrictions)) {
            data["identityProviderRestrictions"] = [];
            for (let item of this.identityProviderRestrictions)
                data["identityProviderRestrictions"].push(item);
        }
        if (Array.isArray(this.redirectUris)) {
            data["redirectUris"] = [];
            for (let item of this.redirectUris)
                data["redirectUris"].push(item);
        }
        if (Array.isArray(this.allowedCorsOrigins)) {
            data["allowedCorsOrigins"] = [];
            for (let item of this.allowedCorsOrigins)
                data["allowedCorsOrigins"].push(item);
        }
        if (Array.isArray(this.allowedGrantTypes)) {
            data["allowedGrantTypes"] = [];
            for (let item of this.allowedGrantTypes)
                data["allowedGrantTypes"].push(item);
        }
        if (Array.isArray(this.allowedScopes)) {
            data["allowedScopes"] = [];
            for (let item of this.allowedScopes)
                data["allowedScopes"].push(item);
        }
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        data["lastAccessed"] = this.lastAccessed ? this.lastAccessed.toISOString() : <any>undefined;
        data["userSsoLifetime"] = this.userSsoLifetime;
        data["userCodeType"] = this.userCodeType;
        data["deviceCodeLifetime"] = this.deviceCodeLifetime;
        data["requireRequestObject"] = this.requireRequestObject;
        data["cibaLifetime"] = this.cibaLifetime;
        data["pollingInterval"] = this.pollingInterval;
        data["coordinateLifetimeWithUserSession"] = this.coordinateLifetimeWithUserSession;
        data["requireDPoP"] = this.requireDPoP;
        data["dPoPValidationMode"] = this.dPoPValidationMode;
        data["dPoPClockSkew"] = this.dPoPClockSkew;
        data["pushedAuthorizationLifetime"] = this.pushedAuthorizationLifetime;
        data["requirePushedAuthorization"] = this.requirePushedAuthorization;
        data["initiateLoginUri"] = this.initiateLoginUri;
        if (Array.isArray(this.allowedIdentityTokenSigningAlgorithms)) {
            data["allowedIdentityTokenSigningAlgorithms"] = [];
            for (let item of this.allowedIdentityTokenSigningAlgorithms)
                data["allowedIdentityTokenSigningAlgorithms"].push(item);
        }
        data["nonEditable"] = this.nonEditable;
        return data;
    }
}

export interface IClientApiDto {
    absoluteRefreshTokenLifetime: number;
    accessTokenLifetime: number;
    consentLifetime: number | undefined;
    accessTokenType: number;
    allowAccessTokensViaBrowser: boolean;
    allowOfflineAccess: boolean;
    allowPlainTextPkce: boolean;
    allowRememberConsent: boolean;
    alwaysIncludeUserClaimsInIdToken: boolean;
    alwaysSendClientClaims: boolean;
    authorizationCodeLifetime: number;
    frontChannelLogoutUri: string | undefined;
    frontChannelLogoutSessionRequired: boolean;
    backChannelLogoutUri: string | undefined;
    backChannelLogoutSessionRequired: boolean;
    clientId: string;
    clientName: string;
    clientUri: string | undefined;
    description: string | undefined;
    enabled: boolean;
    enableLocalLogin: boolean;
    id: number;
    identityTokenLifetime: number;
    includeJwtId: boolean;
    logoUri: string | undefined;
    clientClaimsPrefix: string | undefined;
    pairWiseSubjectSalt: string | undefined;
    protocolType: string | undefined;
    refreshTokenExpiration: number;
    refreshTokenUsage: number;
    slidingRefreshTokenLifetime: number;
    requireClientSecret: boolean;
    requireConsent: boolean;
    requirePkce: boolean;
    updateAccessTokenClaimsOnRefresh: boolean;
    postLogoutRedirectUris: string[] | undefined;
    identityProviderRestrictions: string[] | undefined;
    redirectUris: string[] | undefined;
    allowedCorsOrigins: string[] | undefined;
    allowedGrantTypes: string[] | undefined;
    allowedScopes: string[] | undefined;
    claims: ClientClaimApiDto[] | undefined;
    properties: ClientPropertyApiDto[] | undefined;
    updated: Date | undefined;
    lastAccessed: Date | undefined;
    userSsoLifetime: number | undefined;
    userCodeType: string | undefined;
    deviceCodeLifetime: number;
    requireRequestObject: boolean;
    cibaLifetime: number | undefined;
    pollingInterval: number | undefined;
    coordinateLifetimeWithUserSession: boolean;
    requireDPoP: boolean;
    dPoPValidationMode: number;
    dPoPClockSkew: string;
    pushedAuthorizationLifetime: number | undefined;
    requirePushedAuthorization: boolean;
    initiateLoginUri: string | undefined;
    allowedIdentityTokenSigningAlgorithms: string[] | undefined;
    nonEditable: boolean;
}

export class ClientClaimApiDto implements IClientClaimApiDto {
    id!: number;
    type!: string;
    value!: string;

    constructor(data?: IClientClaimApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ClientClaimApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientClaimApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["value"] = this.value;
        return data;
    }
}

export interface IClientClaimApiDto {
    id: number;
    type: string;
    value: string;
}

export class ClientPropertyApiDto implements IClientPropertyApiDto {
    id!: number;
    key!: string | undefined;
    value!: string | undefined;

    constructor(data?: IClientPropertyApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ClientPropertyApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientPropertyApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IClientPropertyApiDto {
    id: number;
    key: string | undefined;
    value: string | undefined;
}

export class SelectItemDto implements ISelectItemDto {
    id!: string | undefined;
    text!: string | undefined;

    constructor(data?: ISelectItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): SelectItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new SelectItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        return data;
    }
}

export interface ISelectItemDto {
    id: string | undefined;
    text: string | undefined;
}

export class ClientCloneApiDto implements IClientCloneApiDto {
    id!: number;
    clientId!: string;
    clientName!: string;
    cloneClientCorsOrigins!: boolean;
    cloneClientRedirectUris!: boolean;
    cloneClientIdPRestrictions!: boolean;
    cloneClientPostLogoutRedirectUris!: boolean;
    cloneClientGrantTypes!: boolean;
    cloneClientScopes!: boolean;
    cloneClientClaims!: boolean;
    cloneClientProperties!: boolean;

    constructor(data?: IClientCloneApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.clientId = _data["clientId"];
            this.clientName = _data["clientName"];
            this.cloneClientCorsOrigins = _data["cloneClientCorsOrigins"];
            this.cloneClientRedirectUris = _data["cloneClientRedirectUris"];
            this.cloneClientIdPRestrictions = _data["cloneClientIdPRestrictions"];
            this.cloneClientPostLogoutRedirectUris = _data["cloneClientPostLogoutRedirectUris"];
            this.cloneClientGrantTypes = _data["cloneClientGrantTypes"];
            this.cloneClientScopes = _data["cloneClientScopes"];
            this.cloneClientClaims = _data["cloneClientClaims"];
            this.cloneClientProperties = _data["cloneClientProperties"];
        }
    }

    static fromJS(data: any): ClientCloneApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientCloneApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["clientId"] = this.clientId;
        data["clientName"] = this.clientName;
        data["cloneClientCorsOrigins"] = this.cloneClientCorsOrigins;
        data["cloneClientRedirectUris"] = this.cloneClientRedirectUris;
        data["cloneClientIdPRestrictions"] = this.cloneClientIdPRestrictions;
        data["cloneClientPostLogoutRedirectUris"] = this.cloneClientPostLogoutRedirectUris;
        data["cloneClientGrantTypes"] = this.cloneClientGrantTypes;
        data["cloneClientScopes"] = this.cloneClientScopes;
        data["cloneClientClaims"] = this.cloneClientClaims;
        data["cloneClientProperties"] = this.cloneClientProperties;
        return data;
    }
}

export interface IClientCloneApiDto {
    id: number;
    clientId: string;
    clientName: string;
    cloneClientCorsOrigins: boolean;
    cloneClientRedirectUris: boolean;
    cloneClientIdPRestrictions: boolean;
    cloneClientPostLogoutRedirectUris: boolean;
    cloneClientGrantTypes: boolean;
    cloneClientScopes: boolean;
    cloneClientClaims: boolean;
    cloneClientProperties: boolean;
}

export class ClientSecretsApiDto implements IClientSecretsApiDto {
    totalCount!: number;
    pageSize!: number;
    clientSecrets!: ClientSecretApiDto[] | undefined;

    constructor(data?: IClientSecretsApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["clientSecrets"])) {
                this.clientSecrets = [] as any;
                for (let item of _data["clientSecrets"])
                    this.clientSecrets!.push(ClientSecretApiDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientSecretsApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientSecretsApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.clientSecrets)) {
            data["clientSecrets"] = [];
            for (let item of this.clientSecrets)
                data["clientSecrets"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClientSecretsApiDto {
    totalCount: number;
    pageSize: number;
    clientSecrets: ClientSecretApiDto[] | undefined;
}

export class ClientSecretApiDto implements IClientSecretApiDto {
    type!: string;
    id!: number;
    description!: string | undefined;
    value!: string;
    hashType!: string | undefined;
    expiration!: Date | undefined;
    created!: Date;

    constructor(data?: IClientSecretApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.id = _data["id"];
            this.description = _data["description"];
            this.value = _data["value"];
            this.hashType = _data["hashType"];
            this.expiration = _data["expiration"] ? new Date(_data["expiration"].toString()) : <any>undefined;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ClientSecretApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientSecretApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["id"] = this.id;
        data["description"] = this.description;
        data["value"] = this.value;
        data["hashType"] = this.hashType;
        data["expiration"] = this.expiration ? this.expiration.toISOString() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data;
    }
}

export interface IClientSecretApiDto {
    type: string;
    id: number;
    description: string | undefined;
    value: string;
    hashType: string | undefined;
    expiration: Date | undefined;
    created: Date;
}

export class ClientPropertiesApiDto implements IClientPropertiesApiDto {
    clientProperties!: ClientPropertyApiDto[] | undefined;
    totalCount!: number;
    pageSize!: number;

    constructor(data?: IClientPropertiesApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["clientProperties"])) {
                this.clientProperties = [] as any;
                for (let item of _data["clientProperties"])
                    this.clientProperties!.push(ClientPropertyApiDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): ClientPropertiesApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientPropertiesApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.clientProperties)) {
            data["clientProperties"] = [];
            for (let item of this.clientProperties)
                data["clientProperties"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IClientPropertiesApiDto {
    clientProperties: ClientPropertyApiDto[] | undefined;
    totalCount: number;
    pageSize: number;
}

export class ClientClaimsApiDto implements IClientClaimsApiDto {
    clientClaims!: ClientClaimApiDto[] | undefined;
    totalCount!: number;
    pageSize!: number;

    constructor(data?: IClientClaimsApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["clientClaims"])) {
                this.clientClaims = [] as any;
                for (let item of _data["clientClaims"])
                    this.clientClaims!.push(ClientClaimApiDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): ClientClaimsApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientClaimsApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.clientClaims)) {
            data["clientClaims"] = [];
            for (let item of this.clientClaims)
                data["clientClaims"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IClientClaimsApiDto {
    clientClaims: ClientClaimApiDto[] | undefined;
    totalCount: number;
    pageSize: number;
}

export class ConfigurationIssueDto implements IConfigurationIssueDto {
    resourceId!: number;
    resourceName!: string | undefined;
    message!: ConfigurationIssueMessageEnum;
    issueType!: ConfigurationIssueTypeView;
    resourceType!: ConfigurationResourceType;

    constructor(data?: IConfigurationIssueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.resourceId = _data["resourceId"];
            this.resourceName = _data["resourceName"];
            this.message = _data["message"];
            this.issueType = _data["issueType"];
            this.resourceType = _data["resourceType"];
        }
    }

    static fromJS(data: any): ConfigurationIssueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConfigurationIssueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resourceId"] = this.resourceId;
        data["resourceName"] = this.resourceName;
        data["message"] = this.message;
        data["issueType"] = this.issueType;
        data["resourceType"] = this.resourceType;
        return data;
    }
}

export interface IConfigurationIssueDto {
    resourceId: number;
    resourceName: string | undefined;
    message: ConfigurationIssueMessageEnum;
    issueType: ConfigurationIssueTypeView;
    resourceType: ConfigurationResourceType;
}

export enum ConfigurationIssueMessageEnum {
    ObsoleteImplicitGrant = 0,
    ObsoletePasswordGrant = 1,
    MissingPkce = 2,
}

export enum ConfigurationIssueTypeView {
    Warning = 0,
    Recommendation = 1,
}

export enum ConfigurationResourceType {
    Client = 0,
    IdentityResource = 1,
    ApiResource = 2,
    ApiScope = 3,
}

export class ConfigurationIssueSummaryDto implements IConfigurationIssueSummaryDto {
    warnings!: number;
    recommendations!: number;

    constructor(data?: IConfigurationIssueSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.warnings = _data["warnings"];
            this.recommendations = _data["recommendations"];
        }
    }

    static fromJS(data: any): ConfigurationIssueSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConfigurationIssueSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["warnings"] = this.warnings;
        data["recommendations"] = this.recommendations;
        return data;
    }
}

export interface IConfigurationIssueSummaryDto {
    warnings: number;
    recommendations: number;
}

export class DashboardDto implements IDashboardDto {
    clientsTotal!: number;
    apiResourcesTotal!: number;
    apiScopesTotal!: number;
    identityResourcesTotal!: number;
    identityProvidersTotal!: number;
    auditLogsAvg!: number;
    auditLogsPerDaysTotal!: DashboardAuditLogDto[] | undefined;

    constructor(data?: IDashboardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientsTotal = _data["clientsTotal"];
            this.apiResourcesTotal = _data["apiResourcesTotal"];
            this.apiScopesTotal = _data["apiScopesTotal"];
            this.identityResourcesTotal = _data["identityResourcesTotal"];
            this.identityProvidersTotal = _data["identityProvidersTotal"];
            this.auditLogsAvg = _data["auditLogsAvg"];
            if (Array.isArray(_data["auditLogsPerDaysTotal"])) {
                this.auditLogsPerDaysTotal = [] as any;
                for (let item of _data["auditLogsPerDaysTotal"])
                    this.auditLogsPerDaysTotal!.push(DashboardAuditLogDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DashboardDto {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientsTotal"] = this.clientsTotal;
        data["apiResourcesTotal"] = this.apiResourcesTotal;
        data["apiScopesTotal"] = this.apiScopesTotal;
        data["identityResourcesTotal"] = this.identityResourcesTotal;
        data["identityProvidersTotal"] = this.identityProvidersTotal;
        data["auditLogsAvg"] = this.auditLogsAvg;
        if (Array.isArray(this.auditLogsPerDaysTotal)) {
            data["auditLogsPerDaysTotal"] = [];
            for (let item of this.auditLogsPerDaysTotal)
                data["auditLogsPerDaysTotal"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDashboardDto {
    clientsTotal: number;
    apiResourcesTotal: number;
    apiScopesTotal: number;
    identityResourcesTotal: number;
    identityProvidersTotal: number;
    auditLogsAvg: number;
    auditLogsPerDaysTotal: DashboardAuditLogDto[] | undefined;
}

export class DashboardAuditLogDto implements IDashboardAuditLogDto {
    total!: number;
    created!: Date;

    constructor(data?: IDashboardAuditLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DashboardAuditLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardAuditLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data;
    }
}

export interface IDashboardAuditLogDto {
    total: number;
    created: Date;
}

export class DashboardIdentityDto implements IDashboardIdentityDto {
    usersTotal!: number;
    rolesTotal!: number;

    constructor(data?: IDashboardIdentityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.usersTotal = _data["usersTotal"];
            this.rolesTotal = _data["rolesTotal"];
        }
    }

    static fromJS(data: any): DashboardIdentityDto {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardIdentityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["usersTotal"] = this.usersTotal;
        data["rolesTotal"] = this.rolesTotal;
        return data;
    }
}

export interface IDashboardIdentityDto {
    usersTotal: number;
    rolesTotal: number;
}

export class GoogleSyncPreviewDto implements IGoogleSyncPreviewDto {
    organizationsFromGoogle!: number;
    membersFromGoogle!: number;
    membersWithMissingOrg!: number;
    existingOrganizations!: number;
    existingMembers!: number;
    organizationPaths!: string[] | undefined;
    warnings!: string[] | undefined;
    previewedAt!: Date;

    constructor(data?: IGoogleSyncPreviewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizationsFromGoogle = _data["organizationsFromGoogle"];
            this.membersFromGoogle = _data["membersFromGoogle"];
            this.membersWithMissingOrg = _data["membersWithMissingOrg"];
            this.existingOrganizations = _data["existingOrganizations"];
            this.existingMembers = _data["existingMembers"];
            if (Array.isArray(_data["organizationPaths"])) {
                this.organizationPaths = [] as any;
                for (let item of _data["organizationPaths"])
                    this.organizationPaths!.push(item);
            }
            if (Array.isArray(_data["warnings"])) {
                this.warnings = [] as any;
                for (let item of _data["warnings"])
                    this.warnings!.push(item);
            }
            this.previewedAt = _data["previewedAt"] ? new Date(_data["previewedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GoogleSyncPreviewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GoogleSyncPreviewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationsFromGoogle"] = this.organizationsFromGoogle;
        data["membersFromGoogle"] = this.membersFromGoogle;
        data["membersWithMissingOrg"] = this.membersWithMissingOrg;
        data["existingOrganizations"] = this.existingOrganizations;
        data["existingMembers"] = this.existingMembers;
        if (Array.isArray(this.organizationPaths)) {
            data["organizationPaths"] = [];
            for (let item of this.organizationPaths)
                data["organizationPaths"].push(item);
        }
        if (Array.isArray(this.warnings)) {
            data["warnings"] = [];
            for (let item of this.warnings)
                data["warnings"].push(item);
        }
        data["previewedAt"] = this.previewedAt ? this.previewedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IGoogleSyncPreviewDto {
    organizationsFromGoogle: number;
    membersFromGoogle: number;
    membersWithMissingOrg: number;
    existingOrganizations: number;
    existingMembers: number;
    organizationPaths: string[] | undefined;
    warnings: string[] | undefined;
    previewedAt: Date;
}

export class GoogleSyncResultDto implements IGoogleSyncResultDto {
    success!: boolean;
    message!: string | undefined;
    organizationsCreated!: number;
    organizationsUpdated!: number;
    organizationsDisabled!: number;
    membersSynced!: number;
    membersFailed!: number;
    failedEmails!: string[] | undefined;
    warnings!: string[] | undefined;
    syncedAt!: Date;
    durationMs!: number;

    constructor(data?: IGoogleSyncResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.organizationsCreated = _data["organizationsCreated"];
            this.organizationsUpdated = _data["organizationsUpdated"];
            this.organizationsDisabled = _data["organizationsDisabled"];
            this.membersSynced = _data["membersSynced"];
            this.membersFailed = _data["membersFailed"];
            if (Array.isArray(_data["failedEmails"])) {
                this.failedEmails = [] as any;
                for (let item of _data["failedEmails"])
                    this.failedEmails!.push(item);
            }
            if (Array.isArray(_data["warnings"])) {
                this.warnings = [] as any;
                for (let item of _data["warnings"])
                    this.warnings!.push(item);
            }
            this.syncedAt = _data["syncedAt"] ? new Date(_data["syncedAt"].toString()) : <any>undefined;
            this.durationMs = _data["durationMs"];
        }
    }

    static fromJS(data: any): GoogleSyncResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GoogleSyncResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["organizationsCreated"] = this.organizationsCreated;
        data["organizationsUpdated"] = this.organizationsUpdated;
        data["organizationsDisabled"] = this.organizationsDisabled;
        data["membersSynced"] = this.membersSynced;
        data["membersFailed"] = this.membersFailed;
        if (Array.isArray(this.failedEmails)) {
            data["failedEmails"] = [];
            for (let item of this.failedEmails)
                data["failedEmails"].push(item);
        }
        if (Array.isArray(this.warnings)) {
            data["warnings"] = [];
            for (let item of this.warnings)
                data["warnings"].push(item);
        }
        data["syncedAt"] = this.syncedAt ? this.syncedAt.toISOString() : <any>undefined;
        data["durationMs"] = this.durationMs;
        return data;
    }
}

export interface IGoogleSyncResultDto {
    success: boolean;
    message: string | undefined;
    organizationsCreated: number;
    organizationsUpdated: number;
    organizationsDisabled: number;
    membersSynced: number;
    membersFailed: number;
    failedEmails: string[] | undefined;
    warnings: string[] | undefined;
    syncedAt: Date;
    durationMs: number;
}

export class GoogleSyncRequestDto implements IGoogleSyncRequestDto {
    tenantId!: string | undefined;
    targetEmails!: string[] | undefined;
    syncOrganizations!: boolean;
    syncMembers!: boolean;
    dryRun!: boolean;

    constructor(data?: IGoogleSyncRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["targetEmails"])) {
                this.targetEmails = [] as any;
                for (let item of _data["targetEmails"])
                    this.targetEmails!.push(item);
            }
            this.syncOrganizations = _data["syncOrganizations"];
            this.syncMembers = _data["syncMembers"];
            this.dryRun = _data["dryRun"];
        }
    }

    static fromJS(data: any): GoogleSyncRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new GoogleSyncRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.targetEmails)) {
            data["targetEmails"] = [];
            for (let item of this.targetEmails)
                data["targetEmails"].push(item);
        }
        data["syncOrganizations"] = this.syncOrganizations;
        data["syncMembers"] = this.syncMembers;
        data["dryRun"] = this.dryRun;
        return data;
    }
}

export interface IGoogleSyncRequestDto {
    tenantId: string | undefined;
    targetEmails: string[] | undefined;
    syncOrganizations: boolean;
    syncMembers: boolean;
    dryRun: boolean;
}

export class GroupDto implements IGroupDto {
    id!: string;
    tenantId!: string;
    code!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    groupType!: string | undefined;
    organizationId!: string | undefined;
    organizationName!: string | undefined;
    sourceId!: number | undefined;
    ownerUserId!: string | undefined;
    ownerUserName!: string | undefined;
    isEnabled!: boolean;
    memberCount!: number;
    createdAt!: Date;
    updatedAt!: Date | undefined;

    constructor(data?: IGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.groupType = _data["groupType"];
            this.organizationId = _data["organizationId"];
            this.organizationName = _data["organizationName"];
            this.sourceId = _data["sourceId"];
            this.ownerUserId = _data["ownerUserId"];
            this.ownerUserName = _data["ownerUserName"];
            this.isEnabled = _data["isEnabled"];
            this.memberCount = _data["memberCount"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["groupType"] = this.groupType;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["sourceId"] = this.sourceId;
        data["ownerUserId"] = this.ownerUserId;
        data["ownerUserName"] = this.ownerUserName;
        data["isEnabled"] = this.isEnabled;
        data["memberCount"] = this.memberCount;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IGroupDto {
    id: string;
    tenantId: string;
    code: string | undefined;
    name: string | undefined;
    description: string | undefined;
    groupType: string | undefined;
    organizationId: string | undefined;
    organizationName: string | undefined;
    sourceId: number | undefined;
    ownerUserId: string | undefined;
    ownerUserName: string | undefined;
    isEnabled: boolean;
    memberCount: number;
    createdAt: Date;
    updatedAt: Date | undefined;
}

export class GroupStatsDto implements IGroupStatsDto {
    totalGroups!: number;
    countByType!: { [key: string]: number; } | undefined;
    totalMembers!: number;

    constructor(data?: IGroupStatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalGroups = _data["totalGroups"];
            if (_data["countByType"]) {
                this.countByType = {} as any;
                for (let key in _data["countByType"]) {
                    if (_data["countByType"].hasOwnProperty(key))
                        (<any>this.countByType)![key] = _data["countByType"][key];
                }
            }
            this.totalMembers = _data["totalMembers"];
        }
    }

    static fromJS(data: any): GroupStatsDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupStatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalGroups"] = this.totalGroups;
        if (this.countByType) {
            data["countByType"] = {};
            for (let key in this.countByType) {
                if (this.countByType.hasOwnProperty(key))
                    (<any>data["countByType"])[key] = (<any>this.countByType)[key];
            }
        }
        data["totalMembers"] = this.totalMembers;
        return data;
    }
}

export interface IGroupStatsDto {
    totalGroups: number;
    countByType: { [key: string]: number; } | undefined;
    totalMembers: number;
}

export class CreateGroupDto implements ICreateGroupDto {
    code!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    groupType!: string | undefined;
    organizationId!: string | undefined;
    ownerUserId!: string | undefined;

    constructor(data?: ICreateGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.groupType = _data["groupType"];
            this.organizationId = _data["organizationId"];
            this.ownerUserId = _data["ownerUserId"];
        }
    }

    static fromJS(data: any): CreateGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["groupType"] = this.groupType;
        data["organizationId"] = this.organizationId;
        data["ownerUserId"] = this.ownerUserId;
        return data;
    }
}

export interface ICreateGroupDto {
    code: string | undefined;
    name: string | undefined;
    description: string | undefined;
    groupType: string | undefined;
    organizationId: string | undefined;
    ownerUserId: string | undefined;
}

export class UpdateGroupDto implements IUpdateGroupDto {
    code!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    groupType!: string | undefined;
    organizationId!: string | undefined;
    ownerUserId!: string | undefined;
    isEnabled!: boolean;

    constructor(data?: IUpdateGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.groupType = _data["groupType"];
            this.organizationId = _data["organizationId"];
            this.ownerUserId = _data["ownerUserId"];
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): UpdateGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["groupType"] = this.groupType;
        data["organizationId"] = this.organizationId;
        data["ownerUserId"] = this.ownerUserId;
        data["isEnabled"] = this.isEnabled;
        return data;
    }
}

export interface IUpdateGroupDto {
    code: string | undefined;
    name: string | undefined;
    description: string | undefined;
    groupType: string | undefined;
    organizationId: string | undefined;
    ownerUserId: string | undefined;
    isEnabled: boolean;
}

export class OperationResultDto implements IOperationResultDto {
    success!: boolean;
    message!: string | undefined;
    data!: any | undefined;

    constructor(data?: IOperationResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): OperationResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new OperationResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["data"] = this.data;
        return data;
    }
}

export interface IOperationResultDto {
    success: boolean;
    message: string | undefined;
    data: any | undefined;
}

export class GroupMemberDetailDto implements IGroupMemberDetailDto {
    id!: string;
    groupId!: string;
    userId!: string | undefined;
    userName!: string | undefined;
    displayName!: string | undefined;
    email!: string | undefined;
    memberRole!: string | undefined;
    inheritGroupPermissions!: boolean;
    joinedAt!: Date;

    constructor(data?: IGroupMemberDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.groupId = _data["groupId"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.displayName = _data["displayName"];
            this.email = _data["email"];
            this.memberRole = _data["memberRole"];
            this.inheritGroupPermissions = _data["inheritGroupPermissions"];
            this.joinedAt = _data["joinedAt"] ? new Date(_data["joinedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GroupMemberDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupMemberDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["groupId"] = this.groupId;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["displayName"] = this.displayName;
        data["email"] = this.email;
        data["memberRole"] = this.memberRole;
        data["inheritGroupPermissions"] = this.inheritGroupPermissions;
        data["joinedAt"] = this.joinedAt ? this.joinedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IGroupMemberDetailDto {
    id: string;
    groupId: string;
    userId: string | undefined;
    userName: string | undefined;
    displayName: string | undefined;
    email: string | undefined;
    memberRole: string | undefined;
    inheritGroupPermissions: boolean;
    joinedAt: Date;
}

export class AddGroupMemberDto implements IAddGroupMemberDto {
    userId!: string | undefined;
    memberRole!: string | undefined;
    inheritGroupPermissions!: boolean;

    constructor(data?: IAddGroupMemberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.memberRole = _data["memberRole"];
            this.inheritGroupPermissions = _data["inheritGroupPermissions"];
        }
    }

    static fromJS(data: any): AddGroupMemberDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddGroupMemberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["memberRole"] = this.memberRole;
        data["inheritGroupPermissions"] = this.inheritGroupPermissions;
        return data;
    }
}

export interface IAddGroupMemberDto {
    userId: string | undefined;
    memberRole: string | undefined;
    inheritGroupPermissions: boolean;
}

export class IdentityProvidersApiDto implements IIdentityProvidersApiDto {
    pageSize!: number;
    totalCount!: number;
    identityProviders!: IdentityProviderApiDto[] | undefined;

    constructor(data?: IIdentityProvidersApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["identityProviders"])) {
                this.identityProviders = [] as any;
                for (let item of _data["identityProviders"])
                    this.identityProviders!.push(IdentityProviderApiDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IdentityProvidersApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityProvidersApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.identityProviders)) {
            data["identityProviders"] = [];
            for (let item of this.identityProviders)
                data["identityProviders"].push(item.toJSON());
        }
        return data;
    }
}

export interface IIdentityProvidersApiDto {
    pageSize: number;
    totalCount: number;
    identityProviders: IdentityProviderApiDto[] | undefined;
}

export class IdentityProviderApiDto implements IIdentityProviderApiDto {
    type!: string | undefined;
    id!: number;
    scheme!: string;
    displayName!: string | undefined;
    enabled!: boolean;
    identityProviderProperties!: { [key: string]: string; } | undefined;

    constructor(data?: IIdentityProviderApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.id = _data["id"];
            this.scheme = _data["scheme"];
            this.displayName = _data["displayName"];
            this.enabled = _data["enabled"];
            if (_data["identityProviderProperties"]) {
                this.identityProviderProperties = {} as any;
                for (let key in _data["identityProviderProperties"]) {
                    if (_data["identityProviderProperties"].hasOwnProperty(key))
                        (<any>this.identityProviderProperties)![key] = _data["identityProviderProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): IdentityProviderApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityProviderApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["id"] = this.id;
        data["scheme"] = this.scheme;
        data["displayName"] = this.displayName;
        data["enabled"] = this.enabled;
        if (this.identityProviderProperties) {
            data["identityProviderProperties"] = {};
            for (let key in this.identityProviderProperties) {
                if (this.identityProviderProperties.hasOwnProperty(key))
                    (<any>data["identityProviderProperties"])[key] = (<any>this.identityProviderProperties)[key];
            }
        }
        return data;
    }
}

export interface IIdentityProviderApiDto {
    type: string | undefined;
    id: number;
    scheme: string;
    displayName: string | undefined;
    enabled: boolean;
    identityProviderProperties: { [key: string]: string; } | undefined;
}

export class IdentityResourcesApiDto implements IIdentityResourcesApiDto {
    pageSize!: number;
    totalCount!: number;
    identityResources!: IdentityResourceApiDto[] | undefined;

    constructor(data?: IIdentityResourcesApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["identityResources"])) {
                this.identityResources = [] as any;
                for (let item of _data["identityResources"])
                    this.identityResources!.push(IdentityResourceApiDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IdentityResourcesApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityResourcesApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.identityResources)) {
            data["identityResources"] = [];
            for (let item of this.identityResources)
                data["identityResources"].push(item.toJSON());
        }
        return data;
    }
}

export interface IIdentityResourcesApiDto {
    pageSize: number;
    totalCount: number;
    identityResources: IdentityResourceApiDto[] | undefined;
}

export class IdentityResourceApiDto implements IIdentityResourceApiDto {
    id!: number;
    name!: string;
    displayName!: string | undefined;
    description!: string | undefined;
    enabled!: boolean;
    showInDiscoveryDocument!: boolean;
    required!: boolean;
    emphasize!: boolean;
    userClaims!: string[] | undefined;

    constructor(data?: IIdentityResourceApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.enabled = _data["enabled"];
            this.showInDiscoveryDocument = _data["showInDiscoveryDocument"];
            this.required = _data["required"];
            this.emphasize = _data["emphasize"];
            if (Array.isArray(_data["userClaims"])) {
                this.userClaims = [] as any;
                for (let item of _data["userClaims"])
                    this.userClaims!.push(item);
            }
        }
    }

    static fromJS(data: any): IdentityResourceApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityResourceApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["enabled"] = this.enabled;
        data["showInDiscoveryDocument"] = this.showInDiscoveryDocument;
        data["required"] = this.required;
        data["emphasize"] = this.emphasize;
        if (Array.isArray(this.userClaims)) {
            data["userClaims"] = [];
            for (let item of this.userClaims)
                data["userClaims"].push(item);
        }
        return data;
    }
}

export interface IIdentityResourceApiDto {
    id: number;
    name: string;
    displayName: string | undefined;
    description: string | undefined;
    enabled: boolean;
    showInDiscoveryDocument: boolean;
    required: boolean;
    emphasize: boolean;
    userClaims: string[] | undefined;
}

export class IdentityResourcePropertiesApiDto implements IIdentityResourcePropertiesApiDto {
    totalCount!: number;
    pageSize!: number;
    identityResourceProperties!: IdentityResourcePropertyApiDto[] | undefined;

    constructor(data?: IIdentityResourcePropertiesApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["identityResourceProperties"])) {
                this.identityResourceProperties = [] as any;
                for (let item of _data["identityResourceProperties"])
                    this.identityResourceProperties!.push(IdentityResourcePropertyApiDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IdentityResourcePropertiesApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityResourcePropertiesApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.identityResourceProperties)) {
            data["identityResourceProperties"] = [];
            for (let item of this.identityResourceProperties)
                data["identityResourceProperties"].push(item.toJSON());
        }
        return data;
    }
}

export interface IIdentityResourcePropertiesApiDto {
    totalCount: number;
    pageSize: number;
    identityResourceProperties: IdentityResourcePropertyApiDto[] | undefined;
}

export class IdentityResourcePropertyApiDto implements IIdentityResourcePropertyApiDto {
    id!: number;
    key!: string | undefined;
    value!: string | undefined;

    constructor(data?: IIdentityResourcePropertyApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): IdentityResourcePropertyApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityResourcePropertyApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IIdentityResourcePropertyApiDto {
    id: number;
    key: string | undefined;
    value: string | undefined;
}

export class KeysApiDto implements IKeysApiDto {
    keys!: KeyApiDto[] | undefined;
    totalCount!: number;
    pageSize!: number;

    constructor(data?: IKeysApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["keys"])) {
                this.keys = [] as any;
                for (let item of _data["keys"])
                    this.keys!.push(KeyApiDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): KeysApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new KeysApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.keys)) {
            data["keys"] = [];
            for (let item of this.keys)
                data["keys"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IKeysApiDto {
    keys: KeyApiDto[] | undefined;
    totalCount: number;
    pageSize: number;
}

export class KeyApiDto implements IKeyApiDto {
    id!: string | undefined;
    version!: number;
    created!: Date;
    use!: string | undefined;
    algorithm!: string | undefined;
    isX509Certificate!: boolean;

    constructor(data?: IKeyApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.version = _data["version"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.use = _data["use"];
            this.algorithm = _data["algorithm"];
            this.isX509Certificate = _data["isX509Certificate"];
        }
    }

    static fromJS(data: any): KeyApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new KeyApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["version"] = this.version;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["use"] = this.use;
        data["algorithm"] = this.algorithm;
        data["isX509Certificate"] = this.isX509Certificate;
        return data;
    }
}

export interface IKeyApiDto {
    id: string | undefined;
    version: number;
    created: Date;
    use: string | undefined;
    algorithm: string | undefined;
    isX509Certificate: boolean;
}

export class AuditLogsDto implements IAuditLogsDto {
    deleteOlderThan!: Date;
    logs!: AuditLogDto[] | undefined;
    totalCount!: number;
    pageSize!: number;

    constructor(data?: IAuditLogsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deleteOlderThan = _data["deleteOlderThan"] ? new Date(_data["deleteOlderThan"].toString()) : <any>undefined;
            if (Array.isArray(_data["logs"])) {
                this.logs = [] as any;
                for (let item of _data["logs"])
                    this.logs!.push(AuditLogDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): AuditLogsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deleteOlderThan"] = this.deleteOlderThan ? this.deleteOlderThan.toISOString() : <any>undefined;
        if (Array.isArray(this.logs)) {
            data["logs"] = [];
            for (let item of this.logs)
                data["logs"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IAuditLogsDto {
    deleteOlderThan: Date;
    logs: AuditLogDto[] | undefined;
    totalCount: number;
    pageSize: number;
}

export class AuditLogDto implements IAuditLogDto {
    id!: number;
    event!: string | undefined;
    source!: string | undefined;
    category!: string | undefined;
    subjectIdentifier!: string | undefined;
    subjectName!: string | undefined;
    subjectType!: string | undefined;
    subjectAdditionalData!: string | undefined;
    action!: string | undefined;
    data!: string | undefined;
    created!: Date;

    constructor(data?: IAuditLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.event = _data["event"];
            this.source = _data["source"];
            this.category = _data["category"];
            this.subjectIdentifier = _data["subjectIdentifier"];
            this.subjectName = _data["subjectName"];
            this.subjectType = _data["subjectType"];
            this.subjectAdditionalData = _data["subjectAdditionalData"];
            this.action = _data["action"];
            this.data = _data["data"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AuditLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["event"] = this.event;
        data["source"] = this.source;
        data["category"] = this.category;
        data["subjectIdentifier"] = this.subjectIdentifier;
        data["subjectName"] = this.subjectName;
        data["subjectType"] = this.subjectType;
        data["subjectAdditionalData"] = this.subjectAdditionalData;
        data["action"] = this.action;
        data["data"] = this.data;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data;
    }
}

export interface IAuditLogDto {
    id: number;
    event: string | undefined;
    source: string | undefined;
    category: string | undefined;
    subjectIdentifier: string | undefined;
    subjectName: string | undefined;
    subjectType: string | undefined;
    subjectAdditionalData: string | undefined;
    action: string | undefined;
    data: string | undefined;
    created: Date;
}

export class OrganizationDto implements IOrganizationDto {
    id!: string;
    tenantId!: string;
    code!: string | undefined;
    name!: string | undefined;
    englishName!: string | undefined;
    parentId!: string | undefined;
    path!: string | undefined;
    depth!: number;
    sortOrder!: number;
    managerUserId!: string | undefined;
    managerName!: string | undefined;
    description!: string | undefined;
    inheritParentPermissions!: boolean;
    isEnabled!: boolean;
    memberCount!: number;
    childCount!: number;
    createdAt!: Date;
    updatedAt!: Date | undefined;
    children!: OrganizationDto[] | undefined;

    constructor(data?: IOrganizationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.englishName = _data["englishName"];
            this.parentId = _data["parentId"];
            this.path = _data["path"];
            this.depth = _data["depth"];
            this.sortOrder = _data["sortOrder"];
            this.managerUserId = _data["managerUserId"];
            this.managerName = _data["managerName"];
            this.description = _data["description"];
            this.inheritParentPermissions = _data["inheritParentPermissions"];
            this.isEnabled = _data["isEnabled"];
            this.memberCount = _data["memberCount"];
            this.childCount = _data["childCount"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(OrganizationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrganizationDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["englishName"] = this.englishName;
        data["parentId"] = this.parentId;
        data["path"] = this.path;
        data["depth"] = this.depth;
        data["sortOrder"] = this.sortOrder;
        data["managerUserId"] = this.managerUserId;
        data["managerName"] = this.managerName;
        data["description"] = this.description;
        data["inheritParentPermissions"] = this.inheritParentPermissions;
        data["isEnabled"] = this.isEnabled;
        data["memberCount"] = this.memberCount;
        data["childCount"] = this.childCount;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOrganizationDto {
    id: string;
    tenantId: string;
    code: string | undefined;
    name: string | undefined;
    englishName: string | undefined;
    parentId: string | undefined;
    path: string | undefined;
    depth: number;
    sortOrder: number;
    managerUserId: string | undefined;
    managerName: string | undefined;
    description: string | undefined;
    inheritParentPermissions: boolean;
    isEnabled: boolean;
    memberCount: number;
    childCount: number;
    createdAt: Date;
    updatedAt: Date | undefined;
    children: OrganizationDto[] | undefined;
}

export class OrganizationTreeNodeDto implements IOrganizationTreeNodeDto {
    id!: string;
    name!: string | undefined;
    englishName!: string | undefined;
    code!: string | undefined;
    parentId!: string | undefined;
    depth!: number;
    managerName!: string | undefined;
    memberCount!: number;
    isRoot!: boolean;
    children!: OrganizationTreeNodeDto[] | undefined;

    constructor(data?: IOrganizationTreeNodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.englishName = _data["englishName"];
            this.code = _data["code"];
            this.parentId = _data["parentId"];
            this.depth = _data["depth"];
            this.managerName = _data["managerName"];
            this.memberCount = _data["memberCount"];
            this.isRoot = _data["isRoot"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(OrganizationTreeNodeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrganizationTreeNodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationTreeNodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["englishName"] = this.englishName;
        data["code"] = this.code;
        data["parentId"] = this.parentId;
        data["depth"] = this.depth;
        data["managerName"] = this.managerName;
        data["memberCount"] = this.memberCount;
        data["isRoot"] = this.isRoot;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOrganizationTreeNodeDto {
    id: string;
    name: string | undefined;
    englishName: string | undefined;
    code: string | undefined;
    parentId: string | undefined;
    depth: number;
    managerName: string | undefined;
    memberCount: number;
    isRoot: boolean;
    children: OrganizationTreeNodeDto[] | undefined;
}

export class OrganizationStatsDto implements IOrganizationStatsDto {
    totalOrganizations!: number;
    totalMembers!: number;
    maxDepth!: number;

    constructor(data?: IOrganizationStatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalOrganizations = _data["totalOrganizations"];
            this.totalMembers = _data["totalMembers"];
            this.maxDepth = _data["maxDepth"];
        }
    }

    static fromJS(data: any): OrganizationStatsDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationStatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalOrganizations"] = this.totalOrganizations;
        data["totalMembers"] = this.totalMembers;
        data["maxDepth"] = this.maxDepth;
        return data;
    }
}

export interface IOrganizationStatsDto {
    totalOrganizations: number;
    totalMembers: number;
    maxDepth: number;
}

export class CreateOrganizationDto implements ICreateOrganizationDto {
    name!: string | undefined;
    englishName!: string | undefined;
    code!: string | undefined;
    parentId!: string | undefined;
    managerUserId!: string | undefined;
    description!: string | undefined;
    sortOrder!: number;
    inheritParentPermissions!: boolean;

    constructor(data?: ICreateOrganizationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.englishName = _data["englishName"];
            this.code = _data["code"];
            this.parentId = _data["parentId"];
            this.managerUserId = _data["managerUserId"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.inheritParentPermissions = _data["inheritParentPermissions"];
        }
    }

    static fromJS(data: any): CreateOrganizationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["englishName"] = this.englishName;
        data["code"] = this.code;
        data["parentId"] = this.parentId;
        data["managerUserId"] = this.managerUserId;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["inheritParentPermissions"] = this.inheritParentPermissions;
        return data;
    }
}

export interface ICreateOrganizationDto {
    name: string | undefined;
    englishName: string | undefined;
    code: string | undefined;
    parentId: string | undefined;
    managerUserId: string | undefined;
    description: string | undefined;
    sortOrder: number;
    inheritParentPermissions: boolean;
}

export class UpdateOrganizationDto implements IUpdateOrganizationDto {
    name!: string | undefined;
    englishName!: string | undefined;
    code!: string | undefined;
    parentId!: string | undefined;
    managerUserId!: string | undefined;
    description!: string | undefined;
    sortOrder!: number;
    inheritParentPermissions!: boolean;

    constructor(data?: IUpdateOrganizationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.englishName = _data["englishName"];
            this.code = _data["code"];
            this.parentId = _data["parentId"];
            this.managerUserId = _data["managerUserId"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.inheritParentPermissions = _data["inheritParentPermissions"];
        }
    }

    static fromJS(data: any): UpdateOrganizationDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrganizationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["englishName"] = this.englishName;
        data["code"] = this.code;
        data["parentId"] = this.parentId;
        data["managerUserId"] = this.managerUserId;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["inheritParentPermissions"] = this.inheritParentPermissions;
        return data;
    }
}

export interface IUpdateOrganizationDto {
    name: string | undefined;
    englishName: string | undefined;
    code: string | undefined;
    parentId: string | undefined;
    managerUserId: string | undefined;
    description: string | undefined;
    sortOrder: number;
    inheritParentPermissions: boolean;
}

export class OrganizationMemberDto implements IOrganizationMemberDto {
    id!: string;
    organizationId!: string;
    organizationName!: string | undefined;
    userId!: string | undefined;
    userName!: string | undefined;
    displayName!: string | undefined;
    email!: string | undefined;
    positionId!: string | undefined;
    positionName!: string | undefined;
    memberRole!: string | undefined;
    isPrimary!: boolean;
    joinedAt!: Date;

    constructor(data?: IOrganizationMemberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.organizationId = _data["organizationId"];
            this.organizationName = _data["organizationName"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.displayName = _data["displayName"];
            this.email = _data["email"];
            this.positionId = _data["positionId"];
            this.positionName = _data["positionName"];
            this.memberRole = _data["memberRole"];
            this.isPrimary = _data["isPrimary"];
            this.joinedAt = _data["joinedAt"] ? new Date(_data["joinedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): OrganizationMemberDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationMemberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["displayName"] = this.displayName;
        data["email"] = this.email;
        data["positionId"] = this.positionId;
        data["positionName"] = this.positionName;
        data["memberRole"] = this.memberRole;
        data["isPrimary"] = this.isPrimary;
        data["joinedAt"] = this.joinedAt ? this.joinedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IOrganizationMemberDto {
    id: string;
    organizationId: string;
    organizationName: string | undefined;
    userId: string | undefined;
    userName: string | undefined;
    displayName: string | undefined;
    email: string | undefined;
    positionId: string | undefined;
    positionName: string | undefined;
    memberRole: string | undefined;
    isPrimary: boolean;
    joinedAt: Date;
}

export class AddOrganizationMemberDto implements IAddOrganizationMemberDto {
    organizationId!: string;
    userId!: string | undefined;
    positionId!: string | undefined;
    memberRole!: string | undefined;
    isPrimary!: boolean;

    constructor(data?: IAddOrganizationMemberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizationId = _data["organizationId"];
            this.userId = _data["userId"];
            this.positionId = _data["positionId"];
            this.memberRole = _data["memberRole"];
            this.isPrimary = _data["isPrimary"];
        }
    }

    static fromJS(data: any): AddOrganizationMemberDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrganizationMemberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationId"] = this.organizationId;
        data["userId"] = this.userId;
        data["positionId"] = this.positionId;
        data["memberRole"] = this.memberRole;
        data["isPrimary"] = this.isPrimary;
        return data;
    }
}

export interface IAddOrganizationMemberDto {
    organizationId: string;
    userId: string | undefined;
    positionId: string | undefined;
    memberRole: string | undefined;
    isPrimary: boolean;
}

export class PositionDto implements IPositionDto {
    id!: string;
    code!: string | undefined;
    name!: string | undefined;
    level!: number;
    permissions!: string | undefined;
    isEnabled!: boolean;

    constructor(data?: IPositionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.level = _data["level"];
            this.permissions = _data["permissions"];
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): PositionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PositionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["level"] = this.level;
        data["permissions"] = this.permissions;
        data["isEnabled"] = this.isEnabled;
        return data;
    }
}

export interface IPositionDto {
    id: string;
    code: string | undefined;
    name: string | undefined;
    level: number;
    permissions: string | undefined;
    isEnabled: boolean;
}

export class PermissionResourceDto implements IPermissionResourceDto {
    id!: string;
    clientId!: string | undefined;
    clientName!: string | undefined;
    code!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    uri!: string | undefined;
    resourceType!: string | undefined;
    parentId!: string | undefined;
    sortOrder!: number;
    isEnabled!: boolean;
    children!: PermissionResourceDto[] | undefined;

    constructor(data?: IPermissionResourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.clientId = _data["clientId"];
            this.clientName = _data["clientName"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.uri = _data["uri"];
            this.resourceType = _data["resourceType"];
            this.parentId = _data["parentId"];
            this.sortOrder = _data["sortOrder"];
            this.isEnabled = _data["isEnabled"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(PermissionResourceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionResourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionResourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["clientId"] = this.clientId;
        data["clientName"] = this.clientName;
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["uri"] = this.uri;
        data["resourceType"] = this.resourceType;
        data["parentId"] = this.parentId;
        data["sortOrder"] = this.sortOrder;
        data["isEnabled"] = this.isEnabled;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPermissionResourceDto {
    id: string;
    clientId: string | undefined;
    clientName: string | undefined;
    code: string | undefined;
    name: string | undefined;
    description: string | undefined;
    uri: string | undefined;
    resourceType: string | undefined;
    parentId: string | undefined;
    sortOrder: number;
    isEnabled: boolean;
    children: PermissionResourceDto[] | undefined;
}

export class PermissionScopeDto implements IPermissionScopeDto {
    id!: string;
    code!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;

    constructor(data?: IPermissionScopeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): PermissionScopeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionScopeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface IPermissionScopeDto {
    id: string;
    code: string | undefined;
    name: string | undefined;
    description: string | undefined;
}

export class PermissionDto implements IPermissionDto {
    id!: string;
    tenantId!: string | undefined;
    subjectType!: string | undefined;
    subjectId!: string | undefined;
    subjectName!: string | undefined;
    resourceId!: string;
    resourceCode!: string | undefined;
    resourceName!: string | undefined;
    clientId!: string | undefined;
    scopes!: string | undefined;
    scopeList!: string[] | undefined;
    inheritToChildren!: boolean;
    isEnabled!: boolean;
    grantedBy!: string | undefined;
    grantedAt!: Date;
    expiresAt!: Date | undefined;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.subjectType = _data["subjectType"];
            this.subjectId = _data["subjectId"];
            this.subjectName = _data["subjectName"];
            this.resourceId = _data["resourceId"];
            this.resourceCode = _data["resourceCode"];
            this.resourceName = _data["resourceName"];
            this.clientId = _data["clientId"];
            this.scopes = _data["scopes"];
            if (Array.isArray(_data["scopeList"])) {
                this.scopeList = [] as any;
                for (let item of _data["scopeList"])
                    this.scopeList!.push(item);
            }
            this.inheritToChildren = _data["inheritToChildren"];
            this.isEnabled = _data["isEnabled"];
            this.grantedBy = _data["grantedBy"];
            this.grantedAt = _data["grantedAt"] ? new Date(_data["grantedAt"].toString()) : <any>undefined;
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["subjectType"] = this.subjectType;
        data["subjectId"] = this.subjectId;
        data["subjectName"] = this.subjectName;
        data["resourceId"] = this.resourceId;
        data["resourceCode"] = this.resourceCode;
        data["resourceName"] = this.resourceName;
        data["clientId"] = this.clientId;
        data["scopes"] = this.scopes;
        if (Array.isArray(this.scopeList)) {
            data["scopeList"] = [];
            for (let item of this.scopeList)
                data["scopeList"].push(item);
        }
        data["inheritToChildren"] = this.inheritToChildren;
        data["isEnabled"] = this.isEnabled;
        data["grantedBy"] = this.grantedBy;
        data["grantedAt"] = this.grantedAt ? this.grantedAt.toISOString() : <any>undefined;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IPermissionDto {
    id: string;
    tenantId: string | undefined;
    subjectType: string | undefined;
    subjectId: string | undefined;
    subjectName: string | undefined;
    resourceId: string;
    resourceCode: string | undefined;
    resourceName: string | undefined;
    clientId: string | undefined;
    scopes: string | undefined;
    scopeList: string[] | undefined;
    inheritToChildren: boolean;
    isEnabled: boolean;
    grantedBy: string | undefined;
    grantedAt: Date;
    expiresAt: Date | undefined;
}

export class UserEffectivePermissionsDto implements IUserEffectivePermissionsDto {
    userId!: string | undefined;
    userName!: string | undefined;
    permissions!: EffectivePermissionDto[] | undefined;

    constructor(data?: IUserEffectivePermissionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(EffectivePermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserEffectivePermissionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserEffectivePermissionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserEffectivePermissionsDto {
    userId: string | undefined;
    userName: string | undefined;
    permissions: EffectivePermissionDto[] | undefined;
}

export class EffectivePermissionDto implements IEffectivePermissionDto {
    resourceId!: string;
    resourceCode!: string | undefined;
    resourceName!: string | undefined;
    clientId!: string | undefined;
    scopes!: string[] | undefined;
    source!: string | undefined;
    sourceId!: string | undefined;
    sourceName!: string | undefined;

    constructor(data?: IEffectivePermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.resourceId = _data["resourceId"];
            this.resourceCode = _data["resourceCode"];
            this.resourceName = _data["resourceName"];
            this.clientId = _data["clientId"];
            if (Array.isArray(_data["scopes"])) {
                this.scopes = [] as any;
                for (let item of _data["scopes"])
                    this.scopes!.push(item);
            }
            this.source = _data["source"];
            this.sourceId = _data["sourceId"];
            this.sourceName = _data["sourceName"];
        }
    }

    static fromJS(data: any): EffectivePermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new EffectivePermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resourceId"] = this.resourceId;
        data["resourceCode"] = this.resourceCode;
        data["resourceName"] = this.resourceName;
        data["clientId"] = this.clientId;
        if (Array.isArray(this.scopes)) {
            data["scopes"] = [];
            for (let item of this.scopes)
                data["scopes"].push(item);
        }
        data["source"] = this.source;
        data["sourceId"] = this.sourceId;
        data["sourceName"] = this.sourceName;
        return data;
    }
}

export interface IEffectivePermissionDto {
    resourceId: string;
    resourceCode: string | undefined;
    resourceName: string | undefined;
    clientId: string | undefined;
    scopes: string[] | undefined;
    source: string | undefined;
    sourceId: string | undefined;
    sourceName: string | undefined;
}

/**  DTO */
export class PermissionCheckResultDto implements IPermissionCheckResultDto {
    userId!: string | undefined;
    resourceId!: string | undefined;
    clientId!: string | undefined;
    resourceCode!: string | undefined;
    scope!: string | undefined;
    hasPermission!: boolean;

    constructor(data?: IPermissionCheckResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.resourceId = _data["resourceId"];
            this.clientId = _data["clientId"];
            this.resourceCode = _data["resourceCode"];
            this.scope = _data["scope"];
            this.hasPermission = _data["hasPermission"];
        }
    }

    static fromJS(data: any): PermissionCheckResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionCheckResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["resourceId"] = this.resourceId;
        data["clientId"] = this.clientId;
        data["resourceCode"] = this.resourceCode;
        data["scope"] = this.scope;
        data["hasPermission"] = this.hasPermission;
        return data;
    }
}

/**  DTO */
export interface IPermissionCheckResultDto {
    userId: string | undefined;
    resourceId: string | undefined;
    clientId: string | undefined;
    resourceCode: string | undefined;
    scope: string | undefined;
    hasPermission: boolean;
}

export class GrantPermissionDto implements IGrantPermissionDto {
    subjectType!: string | undefined;
    subjectId!: string | undefined;
    subjectName!: string | undefined;
    resourceId!: string;
    scopes!: string[] | undefined;
    inheritToChildren!: boolean;
    expiresAt!: Date | undefined;

    constructor(data?: IGrantPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subjectType = _data["subjectType"];
            this.subjectId = _data["subjectId"];
            this.subjectName = _data["subjectName"];
            this.resourceId = _data["resourceId"];
            if (Array.isArray(_data["scopes"])) {
                this.scopes = [] as any;
                for (let item of _data["scopes"])
                    this.scopes!.push(item);
            }
            this.inheritToChildren = _data["inheritToChildren"];
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GrantPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new GrantPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subjectType"] = this.subjectType;
        data["subjectId"] = this.subjectId;
        data["subjectName"] = this.subjectName;
        data["resourceId"] = this.resourceId;
        if (Array.isArray(this.scopes)) {
            data["scopes"] = [];
            for (let item of this.scopes)
                data["scopes"].push(item);
        }
        data["inheritToChildren"] = this.inheritToChildren;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IGrantPermissionDto {
    subjectType: string | undefined;
    subjectId: string | undefined;
    subjectName: string | undefined;
    resourceId: string;
    scopes: string[] | undefined;
    inheritToChildren: boolean;
    expiresAt: Date | undefined;
}

export class BatchGrantPermissionDto implements IBatchGrantPermissionDto {
    subjectType!: string | undefined;
    subjectId!: string | undefined;
    subjectName!: string | undefined;
    resourceScopes!: ResourceScopeDto[] | undefined;
    inheritToChildren!: boolean;

    constructor(data?: IBatchGrantPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subjectType = _data["subjectType"];
            this.subjectId = _data["subjectId"];
            this.subjectName = _data["subjectName"];
            if (Array.isArray(_data["resourceScopes"])) {
                this.resourceScopes = [] as any;
                for (let item of _data["resourceScopes"])
                    this.resourceScopes!.push(ResourceScopeDto.fromJS(item));
            }
            this.inheritToChildren = _data["inheritToChildren"];
        }
    }

    static fromJS(data: any): BatchGrantPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new BatchGrantPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subjectType"] = this.subjectType;
        data["subjectId"] = this.subjectId;
        data["subjectName"] = this.subjectName;
        if (Array.isArray(this.resourceScopes)) {
            data["resourceScopes"] = [];
            for (let item of this.resourceScopes)
                data["resourceScopes"].push(item.toJSON());
        }
        data["inheritToChildren"] = this.inheritToChildren;
        return data;
    }
}

export interface IBatchGrantPermissionDto {
    subjectType: string | undefined;
    subjectId: string | undefined;
    subjectName: string | undefined;
    resourceScopes: ResourceScopeDto[] | undefined;
    inheritToChildren: boolean;
}

export class ResourceScopeDto implements IResourceScopeDto {
    resourceId!: string;
    scopes!: string[] | undefined;

    constructor(data?: IResourceScopeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.resourceId = _data["resourceId"];
            if (Array.isArray(_data["scopes"])) {
                this.scopes = [] as any;
                for (let item of _data["scopes"])
                    this.scopes!.push(item);
            }
        }
    }

    static fromJS(data: any): ResourceScopeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResourceScopeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resourceId"] = this.resourceId;
        if (Array.isArray(this.scopes)) {
            data["scopes"] = [];
            for (let item of this.scopes)
                data["scopes"].push(item);
        }
        return data;
    }
}

export interface IResourceScopeDto {
    resourceId: string;
    scopes: string[] | undefined;
}

/**  DTO */
export class UpdatePermissionDto implements IUpdatePermissionDto {
    scopes!: string[] | undefined;
    inheritToChildren!: boolean;
    expiresAt!: Date | undefined;

    constructor(data?: IUpdatePermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["scopes"])) {
                this.scopes = [] as any;
                for (let item of _data["scopes"])
                    this.scopes!.push(item);
            }
            this.inheritToChildren = _data["inheritToChildren"];
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdatePermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.scopes)) {
            data["scopes"] = [];
            for (let item of this.scopes)
                data["scopes"].push(item);
        }
        data["inheritToChildren"] = this.inheritToChildren;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : <any>undefined;
        return data;
    }
}

/**  DTO */
export interface IUpdatePermissionDto {
    scopes: string[] | undefined;
    inheritToChildren: boolean;
    expiresAt: Date | undefined;
}

/**  URL  */
export class AuthorizeUrlResponse implements IAuthorizeUrlResponse {
    /**  URL */
    url!: string | undefined;

    constructor(data?: IAuthorizeUrlResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): AuthorizeUrlResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuthorizeUrlResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        return data;
    }
}

/**  URL  */
export interface IAuthorizeUrlResponse {
    /**  URL */
    url: string | undefined;
}

/**  URL  -  OAuth 2.0  URL */
export class AuthorizeUrlRequest implements IAuthorizeUrlRequest {
    /**  ID */
    clientId!: string | undefined;
    /**  URI */
    redirectUri!: string | undefined;
    /**  Scope */
    scope!: string | undefined;
    /** State  */
    state!: string | undefined;
    /** PKCE Code Challenge */
    codeChallenge!: string | undefined;
    /**  */
    idp!: string | undefined;
    /**  */
    forceLogin!: boolean;

    constructor(data?: IAuthorizeUrlRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.redirectUri = _data["redirectUri"];
            this.scope = _data["scope"];
            this.state = _data["state"];
            this.codeChallenge = _data["codeChallenge"];
            this.idp = _data["idp"];
            this.forceLogin = _data["forceLogin"];
        }
    }

    static fromJS(data: any): AuthorizeUrlRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AuthorizeUrlRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["redirectUri"] = this.redirectUri;
        data["scope"] = this.scope;
        data["state"] = this.state;
        data["codeChallenge"] = this.codeChallenge;
        data["idp"] = this.idp;
        data["forceLogin"] = this.forceLogin;
        return data;
    }
}

/**  URL  -  OAuth 2.0  URL */
export interface IAuthorizeUrlRequest {
    /**  ID */
    clientId: string | undefined;
    /**  URI */
    redirectUri: string | undefined;
    /**  Scope */
    scope: string | undefined;
    /** State  */
    state: string | undefined;
    /** PKCE Code Challenge */
    codeChallenge: string | undefined;
    /**  */
    idp: string | undefined;
    /**  */
    forceLogin: boolean;
}

/** Token  -  Token */
export class TokenRequest implements ITokenRequest {
    /**  */
    code!: string | undefined;
    /**  URI */
    redirectUri!: string | undefined;
    /**  ID */
    clientId!: string | undefined;
    /**  */
    clientSecret!: string | undefined;
    /** PKCE Code Verifier */
    codeVerifier!: string | undefined;

    constructor(data?: ITokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.redirectUri = _data["redirectUri"];
            this.clientId = _data["clientId"];
            this.clientSecret = _data["clientSecret"];
            this.codeVerifier = _data["codeVerifier"];
        }
    }

    static fromJS(data: any): TokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["redirectUri"] = this.redirectUri;
        data["clientId"] = this.clientId;
        data["clientSecret"] = this.clientSecret;
        data["codeVerifier"] = this.codeVerifier;
        return data;
    }
}

/** Token  -  Token */
export interface ITokenRequest {
    /**  */
    code: string | undefined;
    /**  URI */
    redirectUri: string | undefined;
    /**  ID */
    clientId: string | undefined;
    /**  */
    clientSecret: string | undefined;
    /** PKCE Code Verifier */
    codeVerifier: string | undefined;
}

/**  Token  -  Access Token */
export class RefreshTokenRequest implements IRefreshTokenRequest {
    /** Refresh Token */
    refreshToken!: string | undefined;
    /**  ID */
    clientId!: string | undefined;
    /**  */
    clientSecret!: string | undefined;

    constructor(data?: IRefreshTokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refreshToken = _data["refreshToken"];
            this.clientId = _data["clientId"];
            this.clientSecret = _data["clientSecret"];
        }
    }

    static fromJS(data: any): RefreshTokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refreshToken"] = this.refreshToken;
        data["clientId"] = this.clientId;
        data["clientSecret"] = this.clientSecret;
        return data;
    }
}

/**  Token  -  Access Token */
export interface IRefreshTokenRequest {
    /** Refresh Token */
    refreshToken: string | undefined;
    /**  ID */
    clientId: string | undefined;
    /**  */
    clientSecret: string | undefined;
}

/** Client Credentials  -  */
export class ClientCredentialsRequest implements IClientCredentialsRequest {
    /**  ID */
    clientId!: string | undefined;
    /**  */
    clientSecret!: string | undefined;
    /**  Scope */
    scope!: string | undefined;

    constructor(data?: IClientCredentialsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.clientSecret = _data["clientSecret"];
            this.scope = _data["scope"];
        }
    }

    static fromJS(data: any): ClientCredentialsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ClientCredentialsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["clientSecret"] = this.clientSecret;
        data["scope"] = this.scope;
        return data;
    }
}

/** Client Credentials  -  */
export interface IClientCredentialsRequest {
    /**  ID */
    clientId: string | undefined;
    /**  */
    clientSecret: string | undefined;
    /**  Scope */
    scope: string | undefined;
}

/** Token  -  Token  */
export class IntrospectRequest implements IIntrospectRequest {
    /**  Token */
    token!: string | undefined;
    /**  ID */
    clientId!: string | undefined;
    /**  */
    clientSecret!: string | undefined;

    constructor(data?: IIntrospectRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.clientId = _data["clientId"];
            this.clientSecret = _data["clientSecret"];
        }
    }

    static fromJS(data: any): IntrospectRequest {
        data = typeof data === 'object' ? data : {};
        let result = new IntrospectRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["clientId"] = this.clientId;
        data["clientSecret"] = this.clientSecret;
        return data;
    }
}

/** Token  -  Token  */
export interface IIntrospectRequest {
    /**  Token */
    token: string | undefined;
    /**  ID */
    clientId: string | undefined;
    /**  */
    clientSecret: string | undefined;
}

/**  */
export class RevokeResponse implements IRevokeResponse {
    /**  */
    success!: boolean;

    constructor(data?: IRevokeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): RevokeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RevokeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        return data;
    }
}

/**  */
export interface IRevokeResponse {
    /**  */
    success: boolean;
}

/**  Token  -  Token  */
export class RevokeRequest implements IRevokeRequest {
    /**  Token */
    token!: string | undefined;
    /** Token  */
    tokenTypeHint!: string | undefined;
    /**  ID */
    clientId!: string | undefined;
    /**  */
    clientSecret!: string | undefined;

    constructor(data?: IRevokeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.tokenTypeHint = _data["tokenTypeHint"];
            this.clientId = _data["clientId"];
            this.clientSecret = _data["clientSecret"];
        }
    }

    static fromJS(data: any): RevokeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RevokeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["tokenTypeHint"] = this.tokenTypeHint;
        data["clientId"] = this.clientId;
        data["clientSecret"] = this.clientSecret;
        return data;
    }
}

/**  Token  -  Token  */
export interface IRevokeRequest {
    /**  Token */
    token: string | undefined;
    /** Token  */
    tokenTypeHint: string | undefined;
    /**  ID */
    clientId: string | undefined;
    /**  */
    clientSecret: string | undefined;
}

/**  URL  */
export class LogoutUrlResponse implements ILogoutUrlResponse {
    /**  URL */
    url!: string | undefined;

    constructor(data?: ILogoutUrlResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): LogoutUrlResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LogoutUrlResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        return data;
    }
}

/**  URL  */
export interface ILogoutUrlResponse {
    /**  URL */
    url: string | undefined;
}

/**  URL  -  URL */
export class LogoutUrlRequest implements ILogoutUrlRequest {
    /** ID Token */
    idTokenHint!: string | undefined;
    /**  URI */
    postLogoutRedirectUri!: string | undefined;

    constructor(data?: ILogoutUrlRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idTokenHint = _data["idTokenHint"];
            this.postLogoutRedirectUri = _data["postLogoutRedirectUri"];
        }
    }

    static fromJS(data: any): LogoutUrlRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LogoutUrlRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idTokenHint"] = this.idTokenHint;
        data["postLogoutRedirectUri"] = this.postLogoutRedirectUri;
        return data;
    }
}

/**  URL  -  URL */
export interface ILogoutUrlRequest {
    /** ID Token */
    idTokenHint: string | undefined;
    /**  URI */
    postLogoutRedirectUri: string | undefined;
}

/**  API DTO */
export class OrganizationGroupApiDto implements IOrganizationGroupApiDto {
    id!: string | undefined;
    name!: string | undefined;
    path!: string | undefined;
    parentId!: string | undefined;
    description!: string | undefined;
    subGroupCount!: number;
    depth!: number;
    deptCode!: string | undefined;
    deptEName!: string | undefined;
    deptZhName!: string | undefined;
    manager!: string | undefined;
    enabled!: boolean;
    insDate!: Date | undefined;
    updDate!: Date | undefined;

    constructor(data?: IOrganizationGroupApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.path = _data["path"];
            this.parentId = _data["parentId"];
            this.description = _data["description"];
            this.subGroupCount = _data["subGroupCount"];
            this.depth = _data["depth"];
            this.deptCode = _data["deptCode"];
            this.deptEName = _data["deptEName"];
            this.deptZhName = _data["deptZhName"];
            this.manager = _data["manager"];
            this.enabled = _data["enabled"];
            this.insDate = _data["insDate"] ? new Date(_data["insDate"].toString()) : <any>undefined;
            this.updDate = _data["updDate"] ? new Date(_data["updDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): OrganizationGroupApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationGroupApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["path"] = this.path;
        data["parentId"] = this.parentId;
        data["description"] = this.description;
        data["subGroupCount"] = this.subGroupCount;
        data["depth"] = this.depth;
        data["deptCode"] = this.deptCode;
        data["deptEName"] = this.deptEName;
        data["deptZhName"] = this.deptZhName;
        data["manager"] = this.manager;
        data["enabled"] = this.enabled;
        data["insDate"] = this.insDate ? this.insDate.toISOString() : <any>undefined;
        data["updDate"] = this.updDate ? this.updDate.toISOString() : <any>undefined;
        return data;
    }
}

/**  API DTO */
export interface IOrganizationGroupApiDto {
    id: string | undefined;
    name: string | undefined;
    path: string | undefined;
    parentId: string | undefined;
    description: string | undefined;
    subGroupCount: number;
    depth: number;
    deptCode: string | undefined;
    deptEName: string | undefined;
    deptZhName: string | undefined;
    manager: string | undefined;
    enabled: boolean;
    insDate: Date | undefined;
    updDate: Date | undefined;
}

/**  API DTO */
export class OrganizationTreeApiDto implements IOrganizationTreeApiDto {
    id!: string | undefined;
    name!: string | undefined;
    parentId!: string | undefined;
    deptCode!: string | undefined;
    deptEName!: string | undefined;
    deptZhName!: string | undefined;
    manager!: string | undefined;
    description!: string | undefined;
    depth!: number;
    isCeo!: boolean;
    isRoot!: boolean;
    childCount!: number;
    /**  */
    memberCount!: number;
    /**  */
    totalMemberCount!: number;
    children!: OrganizationTreeApiDto[] | undefined;

    constructor(data?: IOrganizationTreeApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.parentId = _data["parentId"];
            this.deptCode = _data["deptCode"];
            this.deptEName = _data["deptEName"];
            this.deptZhName = _data["deptZhName"];
            this.manager = _data["manager"];
            this.description = _data["description"];
            this.depth = _data["depth"];
            this.isCeo = _data["isCeo"];
            this.isRoot = _data["isRoot"];
            this.childCount = _data["childCount"];
            this.memberCount = _data["memberCount"];
            this.totalMemberCount = _data["totalMemberCount"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(OrganizationTreeApiDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrganizationTreeApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationTreeApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["parentId"] = this.parentId;
        data["deptCode"] = this.deptCode;
        data["deptEName"] = this.deptEName;
        data["deptZhName"] = this.deptZhName;
        data["manager"] = this.manager;
        data["description"] = this.description;
        data["depth"] = this.depth;
        data["isCeo"] = this.isCeo;
        data["isRoot"] = this.isRoot;
        data["childCount"] = this.childCount;
        data["memberCount"] = this.memberCount;
        data["totalMemberCount"] = this.totalMemberCount;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data;
    }
}

/**  API DTO */
export interface IOrganizationTreeApiDto {
    id: string | undefined;
    name: string | undefined;
    parentId: string | undefined;
    deptCode: string | undefined;
    deptEName: string | undefined;
    deptZhName: string | undefined;
    manager: string | undefined;
    description: string | undefined;
    depth: number;
    isCeo: boolean;
    isRoot: boolean;
    childCount: number;
    /**  */
    memberCount: number;
    /**  */
    totalMemberCount: number;
    children: OrganizationTreeApiDto[] | undefined;
}

/**  API DTO */
export class OrganizationStatsApiDto implements IOrganizationStatsApiDto {
    totalGroups!: number;
    totalRootGroups!: number;
    maxDepth!: number;
    groupsWithManagers!: number;

    constructor(data?: IOrganizationStatsApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalGroups = _data["totalGroups"];
            this.totalRootGroups = _data["totalRootGroups"];
            this.maxDepth = _data["maxDepth"];
            this.groupsWithManagers = _data["groupsWithManagers"];
        }
    }

    static fromJS(data: any): OrganizationStatsApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationStatsApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalGroups"] = this.totalGroups;
        data["totalRootGroups"] = this.totalRootGroups;
        data["maxDepth"] = this.maxDepth;
        data["groupsWithManagers"] = this.groupsWithManagers;
        return data;
    }
}

/**  API DTO */
export interface IOrganizationStatsApiDto {
    totalGroups: number;
    totalRootGroups: number;
    maxDepth: number;
    groupsWithManagers: number;
}

/**  API DTO */
export class DeleteConfirmationApiDto implements IDeleteConfirmationApiDto {
    /**  */
    group!: OrganizationGroupApiDto | undefined;
    /**  */
    descendants!: OrganizationGroupApiDto[] | undefined;
    /**  */
    totalCount!: number;
    /**  */
    hasDescendants!: boolean;

    constructor(data?: IDeleteConfirmationApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.group = _data["group"] ? OrganizationGroupApiDto.fromJS(_data["group"]) : <any>undefined;
            if (Array.isArray(_data["descendants"])) {
                this.descendants = [] as any;
                for (let item of _data["descendants"])
                    this.descendants!.push(OrganizationGroupApiDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.hasDescendants = _data["hasDescendants"];
        }
    }

    static fromJS(data: any): DeleteConfirmationApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteConfirmationApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["group"] = this.group ? this.group.toJSON() : <any>undefined;
        if (Array.isArray(this.descendants)) {
            data["descendants"] = [];
            for (let item of this.descendants)
                data["descendants"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["hasDescendants"] = this.hasDescendants;
        return data;
    }
}

/**  API DTO */
export interface IDeleteConfirmationApiDto {
    /**  */
    group: OrganizationGroupApiDto | undefined;
    /**  */
    descendants: OrganizationGroupApiDto[] | undefined;
    /**  */
    totalCount: number;
    /**  */
    hasDescendants: boolean;
}

/**  API DTO */
export class GroupMemberApiDto implements IGroupMemberApiDto {
    /**  ID */
    groupId!: string | undefined;
    /**  ID */
    userId!: string | undefined;
    /**  */
    userName!: string | undefined;
    /**  */
    displayName!: string | undefined;
    /** Email */
    email!: string | undefined;
    /**  */
    groupName!: string | undefined;
    /**  */
    groupPath!: string | undefined;
    /**  */
    joinedAt!: Date | undefined;

    constructor(data?: IGroupMemberApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupId = _data["groupId"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.displayName = _data["displayName"];
            this.email = _data["email"];
            this.groupName = _data["groupName"];
            this.groupPath = _data["groupPath"];
            this.joinedAt = _data["joinedAt"] ? new Date(_data["joinedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GroupMemberApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupMemberApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["displayName"] = this.displayName;
        data["email"] = this.email;
        data["groupName"] = this.groupName;
        data["groupPath"] = this.groupPath;
        data["joinedAt"] = this.joinedAt ? this.joinedAt.toISOString() : <any>undefined;
        return data;
    }
}

/**  API DTO */
export interface IGroupMemberApiDto {
    /**  ID */
    groupId: string | undefined;
    /**  ID */
    userId: string | undefined;
    /**  */
    userName: string | undefined;
    /**  */
    displayName: string | undefined;
    /** Email */
    email: string | undefined;
    /**  */
    groupName: string | undefined;
    /**  */
    groupPath: string | undefined;
    /**  */
    joinedAt: Date | undefined;
}

/**  API DTO */
export class CreateOrganizationGroupApiDto implements ICreateOrganizationGroupApiDto {
    /**  */
    name!: string;
    /**  IDnull  */
    parentId!: string | undefined;
    /**  */
    deptCode!: string | undefined;
    /**  */
    deptZhName!: string | undefined;
    /**  */
    deptEName!: string | undefined;
    /**  */
    manager!: string | undefined;
    /**  */
    description!: string | undefined;

    constructor(data?: ICreateOrganizationGroupApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.parentId = _data["parentId"];
            this.deptCode = _data["deptCode"];
            this.deptZhName = _data["deptZhName"];
            this.deptEName = _data["deptEName"];
            this.manager = _data["manager"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateOrganizationGroupApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationGroupApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["parentId"] = this.parentId;
        data["deptCode"] = this.deptCode;
        data["deptZhName"] = this.deptZhName;
        data["deptEName"] = this.deptEName;
        data["manager"] = this.manager;
        data["description"] = this.description;
        return data;
    }
}

/**  API DTO */
export interface ICreateOrganizationGroupApiDto {
    /**  */
    name: string;
    /**  IDnull  */
    parentId: string | undefined;
    /**  */
    deptCode: string | undefined;
    /**  */
    deptZhName: string | undefined;
    /**  */
    deptEName: string | undefined;
    /**  */
    manager: string | undefined;
    /**  */
    description: string | undefined;
}

/**  API DTO */
export class UpdateOrganizationGroupApiDto implements IUpdateOrganizationGroupApiDto {
    /**  */
    name!: string;
    /**  IDnull  */
    parentId!: string | undefined;
    /**  */
    deptCode!: string | undefined;
    /**  */
    deptZhName!: string | undefined;
    /**  */
    deptEName!: string | undefined;
    /**  */
    manager!: string | undefined;
    /**  */
    description!: string | undefined;

    constructor(data?: IUpdateOrganizationGroupApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.parentId = _data["parentId"];
            this.deptCode = _data["deptCode"];
            this.deptZhName = _data["deptZhName"];
            this.deptEName = _data["deptEName"];
            this.manager = _data["manager"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateOrganizationGroupApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrganizationGroupApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["parentId"] = this.parentId;
        data["deptCode"] = this.deptCode;
        data["deptZhName"] = this.deptZhName;
        data["deptEName"] = this.deptEName;
        data["manager"] = this.manager;
        data["description"] = this.description;
        return data;
    }
}

/**  API DTO */
export interface IUpdateOrganizationGroupApiDto {
    /**  */
    name: string;
    /**  IDnull  */
    parentId: string | undefined;
    /**  */
    deptCode: string | undefined;
    /**  */
    deptZhName: string | undefined;
    /**  */
    deptEName: string | undefined;
    /**  */
    manager: string | undefined;
    /**  */
    description: string | undefined;
}

/**  API DTO */
export class DeleteResultApiDto implements IDeleteResultApiDto {
    /**  */
    success!: boolean;
    /**  */
    deletedCount!: number;
    /**  */
    message!: string | undefined;

    constructor(data?: IDeleteResultApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.deletedCount = _data["deletedCount"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): DeleteResultApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteResultApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["deletedCount"] = this.deletedCount;
        data["message"] = this.message;
        return data;
    }
}

/**  API DTO */
export interface IDeleteResultApiDto {
    /**  */
    success: boolean;
    /**  */
    deletedCount: number;
    /**  */
    message: string | undefined;
}

export class PermissionStatsDto implements IPermissionStatsDto {
    totalScopes!: number;
    totalResources!: number;
    totalUserPermissions!: number;
    totalGroupPermissions!: number;
    totalClients!: number;
    clientStats!: ClientStatsDto[] | undefined;

    constructor(data?: IPermissionStatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalScopes = _data["totalScopes"];
            this.totalResources = _data["totalResources"];
            this.totalUserPermissions = _data["totalUserPermissions"];
            this.totalGroupPermissions = _data["totalGroupPermissions"];
            this.totalClients = _data["totalClients"];
            if (Array.isArray(_data["clientStats"])) {
                this.clientStats = [] as any;
                for (let item of _data["clientStats"])
                    this.clientStats!.push(ClientStatsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionStatsDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionStatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalScopes"] = this.totalScopes;
        data["totalResources"] = this.totalResources;
        data["totalUserPermissions"] = this.totalUserPermissions;
        data["totalGroupPermissions"] = this.totalGroupPermissions;
        data["totalClients"] = this.totalClients;
        if (Array.isArray(this.clientStats)) {
            data["clientStats"] = [];
            for (let item of this.clientStats)
                data["clientStats"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPermissionStatsDto {
    totalScopes: number;
    totalResources: number;
    totalUserPermissions: number;
    totalGroupPermissions: number;
    totalClients: number;
    clientStats: ClientStatsDto[] | undefined;
}

export class ClientStatsDto implements IClientStatsDto {
    clientId!: string | undefined;
    clientName!: string | undefined;
    scopeCount!: number;
    resourceCount!: number;
    userPermissionCount!: number;
    groupPermissionCount!: number;

    constructor(data?: IClientStatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.clientName = _data["clientName"];
            this.scopeCount = _data["scopeCount"];
            this.resourceCount = _data["resourceCount"];
            this.userPermissionCount = _data["userPermissionCount"];
            this.groupPermissionCount = _data["groupPermissionCount"];
        }
    }

    static fromJS(data: any): ClientStatsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientStatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["clientName"] = this.clientName;
        data["scopeCount"] = this.scopeCount;
        data["resourceCount"] = this.resourceCount;
        data["userPermissionCount"] = this.userPermissionCount;
        data["groupPermissionCount"] = this.groupPermissionCount;
        return data;
    }
}

export interface IClientStatsDto {
    clientId: string | undefined;
    clientName: string | undefined;
    scopeCount: number;
    resourceCount: number;
    userPermissionCount: number;
    groupPermissionCount: number;
}

export class UserBriefDto implements IUserBriefDto {
    id!: string | undefined;
    userName!: string | undefined;
    email!: string | undefined;
    displayName!: string | undefined;
    isActive!: boolean;

    constructor(data?: IUserBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.displayName = _data["displayName"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UserBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["displayName"] = this.displayName;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUserBriefDto {
    id: string | undefined;
    userName: string | undefined;
    email: string | undefined;
    displayName: string | undefined;
    isActive: boolean;
}

export class GroupBriefDto implements IGroupBriefDto {
    id!: string | undefined;
    name!: string | undefined;
    path!: string | undefined;
    deptCode!: string | undefined;
    deptZhName!: string | undefined;

    constructor(data?: IGroupBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.path = _data["path"];
            this.deptCode = _data["deptCode"];
            this.deptZhName = _data["deptZhName"];
        }
    }

    static fromJS(data: any): GroupBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["path"] = this.path;
        data["deptCode"] = this.deptCode;
        data["deptZhName"] = this.deptZhName;
        return data;
    }
}

export interface IGroupBriefDto {
    id: string | undefined;
    name: string | undefined;
    path: string | undefined;
    deptCode: string | undefined;
    deptZhName: string | undefined;
}

export class ScopeDto implements IScopeDto {
    id!: string | undefined;
    clientId!: string | undefined;
    clientName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    iconUri!: string | undefined;
    enabled!: boolean;
    insDate!: Date | undefined;
    updDate!: Date | undefined;

    constructor(data?: IScopeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.clientId = _data["clientId"];
            this.clientName = _data["clientName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.iconUri = _data["iconUri"];
            this.enabled = _data["enabled"];
            this.insDate = _data["insDate"] ? new Date(_data["insDate"].toString()) : <any>undefined;
            this.updDate = _data["updDate"] ? new Date(_data["updDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ScopeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScopeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["clientId"] = this.clientId;
        data["clientName"] = this.clientName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["iconUri"] = this.iconUri;
        data["enabled"] = this.enabled;
        data["insDate"] = this.insDate ? this.insDate.toISOString() : <any>undefined;
        data["updDate"] = this.updDate ? this.updDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IScopeDto {
    id: string | undefined;
    clientId: string | undefined;
    clientName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    iconUri: string | undefined;
    enabled: boolean;
    insDate: Date | undefined;
    updDate: Date | undefined;
}

export class CreateScopeDto implements ICreateScopeDto {
    clientId!: string | undefined;
    clientName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    iconUri!: string | undefined;

    constructor(data?: ICreateScopeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.clientName = _data["clientName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.iconUri = _data["iconUri"];
        }
    }

    static fromJS(data: any): CreateScopeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateScopeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["clientName"] = this.clientName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["iconUri"] = this.iconUri;
        return data;
    }
}

export interface ICreateScopeDto {
    clientId: string | undefined;
    clientName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    iconUri: string | undefined;
}

export class UpdateScopeDto implements IUpdateScopeDto {
    id!: string | undefined;
    clientId!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    iconUri!: string | undefined;

    constructor(data?: IUpdateScopeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.clientId = _data["clientId"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.iconUri = _data["iconUri"];
        }
    }

    static fromJS(data: any): UpdateScopeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateScopeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["clientId"] = this.clientId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["iconUri"] = this.iconUri;
        return data;
    }
}

export interface IUpdateScopeDto {
    id: string | undefined;
    clientId: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    iconUri: string | undefined;
}

export class ResourceDto implements IResourceDto {
    id!: string | undefined;
    clientId!: string | undefined;
    clientName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    type!: string | undefined;
    uri!: string | undefined;
    enabled!: boolean;
    insDate!: Date | undefined;
    updDate!: Date | undefined;
    scopes!: string[] | undefined;

    constructor(data?: IResourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.clientId = _data["clientId"];
            this.clientName = _data["clientName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.type = _data["type"];
            this.uri = _data["uri"];
            this.enabled = _data["enabled"];
            this.insDate = _data["insDate"] ? new Date(_data["insDate"].toString()) : <any>undefined;
            this.updDate = _data["updDate"] ? new Date(_data["updDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["scopes"])) {
                this.scopes = [] as any;
                for (let item of _data["scopes"])
                    this.scopes!.push(item);
            }
        }
    }

    static fromJS(data: any): ResourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["clientId"] = this.clientId;
        data["clientName"] = this.clientName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["type"] = this.type;
        data["uri"] = this.uri;
        data["enabled"] = this.enabled;
        data["insDate"] = this.insDate ? this.insDate.toISOString() : <any>undefined;
        data["updDate"] = this.updDate ? this.updDate.toISOString() : <any>undefined;
        if (Array.isArray(this.scopes)) {
            data["scopes"] = [];
            for (let item of this.scopes)
                data["scopes"].push(item);
        }
        return data;
    }
}

export interface IResourceDto {
    id: string | undefined;
    clientId: string | undefined;
    clientName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    type: string | undefined;
    uri: string | undefined;
    enabled: boolean;
    insDate: Date | undefined;
    updDate: Date | undefined;
    scopes: string[] | undefined;
}

export class CreateResourceDto implements ICreateResourceDto {
    clientId!: string | undefined;
    clientName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    type!: string | undefined;
    uri!: string | undefined;
    scopeIds!: string[] | undefined;

    constructor(data?: ICreateResourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.clientName = _data["clientName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.type = _data["type"];
            this.uri = _data["uri"];
            if (Array.isArray(_data["scopeIds"])) {
                this.scopeIds = [] as any;
                for (let item of _data["scopeIds"])
                    this.scopeIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateResourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateResourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["clientName"] = this.clientName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["type"] = this.type;
        data["uri"] = this.uri;
        if (Array.isArray(this.scopeIds)) {
            data["scopeIds"] = [];
            for (let item of this.scopeIds)
                data["scopeIds"].push(item);
        }
        return data;
    }
}

export interface ICreateResourceDto {
    clientId: string | undefined;
    clientName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    type: string | undefined;
    uri: string | undefined;
    scopeIds: string[] | undefined;
}

export class UpdateResourceDto implements IUpdateResourceDto {
    id!: string | undefined;
    clientId!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    type!: string | undefined;
    uri!: string | undefined;
    scopeIds!: string[] | undefined;

    constructor(data?: IUpdateResourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.clientId = _data["clientId"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.type = _data["type"];
            this.uri = _data["uri"];
            if (Array.isArray(_data["scopeIds"])) {
                this.scopeIds = [] as any;
                for (let item of _data["scopeIds"])
                    this.scopeIds!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateResourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateResourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["clientId"] = this.clientId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["type"] = this.type;
        data["uri"] = this.uri;
        if (Array.isArray(this.scopeIds)) {
            data["scopeIds"] = [];
            for (let item of this.scopeIds)
                data["scopeIds"].push(item);
        }
        return data;
    }
}

export interface IUpdateResourceDto {
    id: string | undefined;
    clientId: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    type: string | undefined;
    uri: string | undefined;
    scopeIds: string[] | undefined;
}

export class ResourceScopeDto2 implements IResourceScopeDto2 {
    resourceId!: string | undefined;
    resourceName!: string | undefined;
    scopeId!: string | undefined;
    scopeName!: string | undefined;
    clientId!: string | undefined;
    insDate!: Date | undefined;

    constructor(data?: IResourceScopeDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.resourceId = _data["resourceId"];
            this.resourceName = _data["resourceName"];
            this.scopeId = _data["scopeId"];
            this.scopeName = _data["scopeName"];
            this.clientId = _data["clientId"];
            this.insDate = _data["insDate"] ? new Date(_data["insDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ResourceScopeDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new ResourceScopeDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resourceId"] = this.resourceId;
        data["resourceName"] = this.resourceName;
        data["scopeId"] = this.scopeId;
        data["scopeName"] = this.scopeName;
        data["clientId"] = this.clientId;
        data["insDate"] = this.insDate ? this.insDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IResourceScopeDto2 {
    resourceId: string | undefined;
    resourceName: string | undefined;
    scopeId: string | undefined;
    scopeName: string | undefined;
    clientId: string | undefined;
    insDate: Date | undefined;
}

export class UserPermissionDto implements IUserPermissionDto {
    userId!: string | undefined;
    username!: string | undefined;
    clientId!: string | undefined;
    clientName!: string | undefined;
    resourceId!: string | undefined;
    resourceName!: string | undefined;
    scopes!: string[] | undefined;
    enabled!: boolean;
    insDate!: Date | undefined;
    updDate!: Date | undefined;

    constructor(data?: IUserPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.username = _data["username"];
            this.clientId = _data["clientId"];
            this.clientName = _data["clientName"];
            this.resourceId = _data["resourceId"];
            this.resourceName = _data["resourceName"];
            if (Array.isArray(_data["scopes"])) {
                this.scopes = [] as any;
                for (let item of _data["scopes"])
                    this.scopes!.push(item);
            }
            this.enabled = _data["enabled"];
            this.insDate = _data["insDate"] ? new Date(_data["insDate"].toString()) : <any>undefined;
            this.updDate = _data["updDate"] ? new Date(_data["updDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["username"] = this.username;
        data["clientId"] = this.clientId;
        data["clientName"] = this.clientName;
        data["resourceId"] = this.resourceId;
        data["resourceName"] = this.resourceName;
        if (Array.isArray(this.scopes)) {
            data["scopes"] = [];
            for (let item of this.scopes)
                data["scopes"].push(item);
        }
        data["enabled"] = this.enabled;
        data["insDate"] = this.insDate ? this.insDate.toISOString() : <any>undefined;
        data["updDate"] = this.updDate ? this.updDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUserPermissionDto {
    userId: string | undefined;
    username: string | undefined;
    clientId: string | undefined;
    clientName: string | undefined;
    resourceId: string | undefined;
    resourceName: string | undefined;
    scopes: string[] | undefined;
    enabled: boolean;
    insDate: Date | undefined;
    updDate: Date | undefined;
}

export class SetUserPermissionDto implements ISetUserPermissionDto {
    userId!: string | undefined;
    username!: string | undefined;
    clientId!: string | undefined;
    clientName!: string | undefined;
    resourceId!: string | undefined;
    resourceName!: string | undefined;
    scopes!: string[] | undefined;

    constructor(data?: ISetUserPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.username = _data["username"];
            this.clientId = _data["clientId"];
            this.clientName = _data["clientName"];
            this.resourceId = _data["resourceId"];
            this.resourceName = _data["resourceName"];
            if (Array.isArray(_data["scopes"])) {
                this.scopes = [] as any;
                for (let item of _data["scopes"])
                    this.scopes!.push(item);
            }
        }
    }

    static fromJS(data: any): SetUserPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new SetUserPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["username"] = this.username;
        data["clientId"] = this.clientId;
        data["clientName"] = this.clientName;
        data["resourceId"] = this.resourceId;
        data["resourceName"] = this.resourceName;
        if (Array.isArray(this.scopes)) {
            data["scopes"] = [];
            for (let item of this.scopes)
                data["scopes"].push(item);
        }
        return data;
    }
}

export interface ISetUserPermissionDto {
    userId: string | undefined;
    username: string | undefined;
    clientId: string | undefined;
    clientName: string | undefined;
    resourceId: string | undefined;
    resourceName: string | undefined;
    scopes: string[] | undefined;
}

export class EffectivePermissionDto2 implements IEffectivePermissionDto2 {
    resourceId!: string | undefined;
    resourceName!: string | undefined;
    clientId!: string | undefined;
    clientName!: string | undefined;
    scopes!: string[] | undefined;
    source!: string | undefined;
    isFromGroup!: boolean;
    sourceGroupId!: string | undefined;
    sourceGroupName!: string | undefined;

    constructor(data?: IEffectivePermissionDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.resourceId = _data["resourceId"];
            this.resourceName = _data["resourceName"];
            this.clientId = _data["clientId"];
            this.clientName = _data["clientName"];
            if (Array.isArray(_data["scopes"])) {
                this.scopes = [] as any;
                for (let item of _data["scopes"])
                    this.scopes!.push(item);
            }
            this.source = _data["source"];
            this.isFromGroup = _data["isFromGroup"];
            this.sourceGroupId = _data["sourceGroupId"];
            this.sourceGroupName = _data["sourceGroupName"];
        }
    }

    static fromJS(data: any): EffectivePermissionDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new EffectivePermissionDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resourceId"] = this.resourceId;
        data["resourceName"] = this.resourceName;
        data["clientId"] = this.clientId;
        data["clientName"] = this.clientName;
        if (Array.isArray(this.scopes)) {
            data["scopes"] = [];
            for (let item of this.scopes)
                data["scopes"].push(item);
        }
        data["source"] = this.source;
        data["isFromGroup"] = this.isFromGroup;
        data["sourceGroupId"] = this.sourceGroupId;
        data["sourceGroupName"] = this.sourceGroupName;
        return data;
    }
}

export interface IEffectivePermissionDto2 {
    resourceId: string | undefined;
    resourceName: string | undefined;
    clientId: string | undefined;
    clientName: string | undefined;
    scopes: string[] | undefined;
    source: string | undefined;
    isFromGroup: boolean;
    sourceGroupId: string | undefined;
    sourceGroupName: string | undefined;
}

export class GroupPermissionDto implements IGroupPermissionDto {
    groupId!: string | undefined;
    groupName!: string | undefined;
    groupPath!: string | undefined;
    clientId!: string | undefined;
    clientName!: string | undefined;
    resourceId!: string | undefined;
    resourceName!: string | undefined;
    scopes!: string[] | undefined;
    inheritToChildren!: boolean;
    enabled!: boolean;
    insDate!: Date | undefined;
    updDate!: Date | undefined;

    constructor(data?: IGroupPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupId = _data["groupId"];
            this.groupName = _data["groupName"];
            this.groupPath = _data["groupPath"];
            this.clientId = _data["clientId"];
            this.clientName = _data["clientName"];
            this.resourceId = _data["resourceId"];
            this.resourceName = _data["resourceName"];
            if (Array.isArray(_data["scopes"])) {
                this.scopes = [] as any;
                for (let item of _data["scopes"])
                    this.scopes!.push(item);
            }
            this.inheritToChildren = _data["inheritToChildren"];
            this.enabled = _data["enabled"];
            this.insDate = _data["insDate"] ? new Date(_data["insDate"].toString()) : <any>undefined;
            this.updDate = _data["updDate"] ? new Date(_data["updDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GroupPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        data["groupName"] = this.groupName;
        data["groupPath"] = this.groupPath;
        data["clientId"] = this.clientId;
        data["clientName"] = this.clientName;
        data["resourceId"] = this.resourceId;
        data["resourceName"] = this.resourceName;
        if (Array.isArray(this.scopes)) {
            data["scopes"] = [];
            for (let item of this.scopes)
                data["scopes"].push(item);
        }
        data["inheritToChildren"] = this.inheritToChildren;
        data["enabled"] = this.enabled;
        data["insDate"] = this.insDate ? this.insDate.toISOString() : <any>undefined;
        data["updDate"] = this.updDate ? this.updDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IGroupPermissionDto {
    groupId: string | undefined;
    groupName: string | undefined;
    groupPath: string | undefined;
    clientId: string | undefined;
    clientName: string | undefined;
    resourceId: string | undefined;
    resourceName: string | undefined;
    scopes: string[] | undefined;
    inheritToChildren: boolean;
    enabled: boolean;
    insDate: Date | undefined;
    updDate: Date | undefined;
}

export class SetGroupPermissionDto implements ISetGroupPermissionDto {
    groupId!: string | undefined;
    groupName!: string | undefined;
    groupPath!: string | undefined;
    clientId!: string | undefined;
    clientName!: string | undefined;
    resourceId!: string | undefined;
    resourceName!: string | undefined;
    scopes!: string[] | undefined;
    inheritToChildren!: boolean;

    constructor(data?: ISetGroupPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupId = _data["groupId"];
            this.groupName = _data["groupName"];
            this.groupPath = _data["groupPath"];
            this.clientId = _data["clientId"];
            this.clientName = _data["clientName"];
            this.resourceId = _data["resourceId"];
            this.resourceName = _data["resourceName"];
            if (Array.isArray(_data["scopes"])) {
                this.scopes = [] as any;
                for (let item of _data["scopes"])
                    this.scopes!.push(item);
            }
            this.inheritToChildren = _data["inheritToChildren"];
        }
    }

    static fromJS(data: any): SetGroupPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new SetGroupPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        data["groupName"] = this.groupName;
        data["groupPath"] = this.groupPath;
        data["clientId"] = this.clientId;
        data["clientName"] = this.clientName;
        data["resourceId"] = this.resourceId;
        data["resourceName"] = this.resourceName;
        if (Array.isArray(this.scopes)) {
            data["scopes"] = [];
            for (let item of this.scopes)
                data["scopes"].push(item);
        }
        data["inheritToChildren"] = this.inheritToChildren;
        return data;
    }
}

export interface ISetGroupPermissionDto {
    groupId: string | undefined;
    groupName: string | undefined;
    groupPath: string | undefined;
    clientId: string | undefined;
    clientName: string | undefined;
    resourceId: string | undefined;
    resourceName: string | undefined;
    scopes: string[] | undefined;
    inheritToChildren: boolean;
}

export class PermissionQueryResponse implements IPermissionQueryResponse {
    userId!: string | undefined;
    userName!: string | undefined;
    userEnglishName!: string | undefined;
    permissions!: SystemPermissionDto[] | undefined;

    constructor(data?: IPermissionQueryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.userEnglishName = _data["userEnglishName"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(SystemPermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionQueryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionQueryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["userEnglishName"] = this.userEnglishName;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPermissionQueryResponse {
    userId: string | undefined;
    userName: string | undefined;
    userEnglishName: string | undefined;
    permissions: SystemPermissionDto[] | undefined;
}

export class SystemPermissionDto implements ISystemPermissionDto {
    systemId!: string | undefined;
    systemName!: string | undefined;
    resources!: ResourcePermissionDto[] | undefined;

    constructor(data?: ISystemPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.systemId = _data["systemId"];
            this.systemName = _data["systemName"];
            if (Array.isArray(_data["resources"])) {
                this.resources = [] as any;
                for (let item of _data["resources"])
                    this.resources!.push(ResourcePermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SystemPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new SystemPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["systemId"] = this.systemId;
        data["systemName"] = this.systemName;
        if (Array.isArray(this.resources)) {
            data["resources"] = [];
            for (let item of this.resources)
                data["resources"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISystemPermissionDto {
    systemId: string | undefined;
    systemName: string | undefined;
    resources: ResourcePermissionDto[] | undefined;
}

export class ResourcePermissionDto implements IResourcePermissionDto {
    resourceId!: number;
    resourceCode!: string | undefined;
    scopes!: ScopeDto2[] | undefined;

    constructor(data?: IResourcePermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.resourceId = _data["resourceId"];
            this.resourceCode = _data["resourceCode"];
            if (Array.isArray(_data["scopes"])) {
                this.scopes = [] as any;
                for (let item of _data["scopes"])
                    this.scopes!.push(ScopeDto2.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResourcePermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResourcePermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resourceId"] = this.resourceId;
        data["resourceCode"] = this.resourceCode;
        if (Array.isArray(this.scopes)) {
            data["scopes"] = [];
            for (let item of this.scopes)
                data["scopes"].push(item.toJSON());
        }
        return data;
    }
}

export interface IResourcePermissionDto {
    resourceId: number;
    resourceCode: string | undefined;
    scopes: ScopeDto2[] | undefined;
}

export class ScopeDto2 implements IScopeDto2 {
    code!: string | undefined;
    name!: string | undefined;

    constructor(data?: IScopeDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ScopeDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new ScopeDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        return data;
    }
}

export interface IScopeDto2 {
    code: string | undefined;
    name: string | undefined;
}

export class PermissionQueryErrorResponse implements IPermissionQueryErrorResponse {
    error!: string | undefined;
    errorDescription!: string | undefined;

    constructor(data?: IPermissionQueryErrorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.error = _data["error"];
            this.errorDescription = _data["errorDescription"];
        }
    }

    static fromJS(data: any): PermissionQueryErrorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionQueryErrorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["error"] = this.error;
        data["errorDescription"] = this.errorDescription;
        return data;
    }
}

export interface IPermissionQueryErrorResponse {
    error: string | undefined;
    errorDescription: string | undefined;
}

export class PermissionQueryRequest implements IPermissionQueryRequest {
    clientId!: string | undefined;
    clientSecret!: string | undefined;
    idToken!: string | undefined;
    accessToken!: string | undefined;
    systemId!: string | undefined;

    constructor(data?: IPermissionQueryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.clientSecret = _data["clientSecret"];
            this.idToken = _data["idToken"];
            this.accessToken = _data["accessToken"];
            this.systemId = _data["systemId"];
        }
    }

    static fromJS(data: any): PermissionQueryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionQueryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["clientSecret"] = this.clientSecret;
        data["idToken"] = this.idToken;
        data["accessToken"] = this.accessToken;
        data["systemId"] = this.systemId;
        return data;
    }
}

export interface IPermissionQueryRequest {
    clientId: string | undefined;
    clientSecret: string | undefined;
    idToken: string | undefined;
    accessToken: string | undefined;
    systemId: string | undefined;
}

export class ScopeCheckResultDto implements IScopeCheckResultDto {
    allowed!: boolean;
    error!: string | undefined;
    errorDescription!: string | undefined;

    constructor(data?: IScopeCheckResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allowed = _data["allowed"];
            this.error = _data["error"];
            this.errorDescription = _data["errorDescription"];
        }
    }

    static fromJS(data: any): ScopeCheckResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScopeCheckResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowed"] = this.allowed;
        data["error"] = this.error;
        data["errorDescription"] = this.errorDescription;
        return data;
    }
}

export interface IScopeCheckResultDto {
    allowed: boolean;
    error: string | undefined;
    errorDescription: string | undefined;
}

export class PermissionCheckRequest implements IPermissionCheckRequest {
    clientId!: string | undefined;
    clientSecret!: string | undefined;
    idToken!: string | undefined;
    accessToken!: string | undefined;
    resource!: string | undefined;
    scopes!: string | undefined;

    constructor(data?: IPermissionCheckRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.clientSecret = _data["clientSecret"];
            this.idToken = _data["idToken"];
            this.accessToken = _data["accessToken"];
            this.resource = _data["resource"];
            this.scopes = _data["scopes"];
        }
    }

    static fromJS(data: any): PermissionCheckRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionCheckRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["clientSecret"] = this.clientSecret;
        data["idToken"] = this.idToken;
        data["accessToken"] = this.accessToken;
        data["resource"] = this.resource;
        data["scopes"] = this.scopes;
        return data;
    }
}

export interface IPermissionCheckRequest {
    clientId: string | undefined;
    clientSecret: string | undefined;
    idToken: string | undefined;
    accessToken: string | undefined;
    resource: string | undefined;
    scopes: string | undefined;
}

export class PersistedGrantSubjectsApiDto implements IPersistedGrantSubjectsApiDto {
    totalCount!: number;
    pageSize!: number;
    persistedGrants!: PersistedGrantSubjectApiDto[] | undefined;

    constructor(data?: IPersistedGrantSubjectsApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["persistedGrants"])) {
                this.persistedGrants = [] as any;
                for (let item of _data["persistedGrants"])
                    this.persistedGrants!.push(PersistedGrantSubjectApiDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PersistedGrantSubjectsApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersistedGrantSubjectsApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.persistedGrants)) {
            data["persistedGrants"] = [];
            for (let item of this.persistedGrants)
                data["persistedGrants"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPersistedGrantSubjectsApiDto {
    totalCount: number;
    pageSize: number;
    persistedGrants: PersistedGrantSubjectApiDto[] | undefined;
}

export class PersistedGrantSubjectApiDto implements IPersistedGrantSubjectApiDto {
    id!: number;
    key!: string | undefined;
    type!: string | undefined;
    subjectId!: string | undefined;
    subjectName!: string | undefined;
    clientId!: string | undefined;
    creationTime!: Date;
    expiration!: Date | undefined;
    data!: string | undefined;
    consumedTime!: Date | undefined;
    sessionId!: string | undefined;
    description!: string | undefined;

    constructor(data?: IPersistedGrantSubjectApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.key = _data["key"];
            this.type = _data["type"];
            this.subjectId = _data["subjectId"];
            this.subjectName = _data["subjectName"];
            this.clientId = _data["clientId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.expiration = _data["expiration"] ? new Date(_data["expiration"].toString()) : <any>undefined;
            this.data = _data["data"];
            this.consumedTime = _data["consumedTime"] ? new Date(_data["consumedTime"].toString()) : <any>undefined;
            this.sessionId = _data["sessionId"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): PersistedGrantSubjectApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersistedGrantSubjectApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["key"] = this.key;
        data["type"] = this.type;
        data["subjectId"] = this.subjectId;
        data["subjectName"] = this.subjectName;
        data["clientId"] = this.clientId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["expiration"] = this.expiration ? this.expiration.toISOString() : <any>undefined;
        data["data"] = this.data;
        data["consumedTime"] = this.consumedTime ? this.consumedTime.toISOString() : <any>undefined;
        data["sessionId"] = this.sessionId;
        data["description"] = this.description;
        return data;
    }
}

export interface IPersistedGrantSubjectApiDto {
    id: number;
    key: string | undefined;
    type: string | undefined;
    subjectId: string | undefined;
    subjectName: string | undefined;
    clientId: string | undefined;
    creationTime: Date;
    expiration: Date | undefined;
    data: string | undefined;
    consumedTime: Date | undefined;
    sessionId: string | undefined;
    description: string | undefined;
}

export class PersistedGrantApiDto implements IPersistedGrantApiDto {
    id!: number;
    key!: string | undefined;
    type!: string | undefined;
    subjectId!: string | undefined;
    subjectName!: string | undefined;
    clientId!: string | undefined;
    creationTime!: Date;
    expiration!: Date | undefined;
    data!: string | undefined;
    consumedTime!: Date | undefined;
    sessionId!: string | undefined;
    description!: string | undefined;

    constructor(data?: IPersistedGrantApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.key = _data["key"];
            this.type = _data["type"];
            this.subjectId = _data["subjectId"];
            this.subjectName = _data["subjectName"];
            this.clientId = _data["clientId"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.expiration = _data["expiration"] ? new Date(_data["expiration"].toString()) : <any>undefined;
            this.data = _data["data"];
            this.consumedTime = _data["consumedTime"] ? new Date(_data["consumedTime"].toString()) : <any>undefined;
            this.sessionId = _data["sessionId"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): PersistedGrantApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersistedGrantApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["key"] = this.key;
        data["type"] = this.type;
        data["subjectId"] = this.subjectId;
        data["subjectName"] = this.subjectName;
        data["clientId"] = this.clientId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["expiration"] = this.expiration ? this.expiration.toISOString() : <any>undefined;
        data["data"] = this.data;
        data["consumedTime"] = this.consumedTime ? this.consumedTime.toISOString() : <any>undefined;
        data["sessionId"] = this.sessionId;
        data["description"] = this.description;
        return data;
    }
}

export interface IPersistedGrantApiDto {
    id: number;
    key: string | undefined;
    type: string | undefined;
    subjectId: string | undefined;
    subjectName: string | undefined;
    clientId: string | undefined;
    creationTime: Date;
    expiration: Date | undefined;
    data: string | undefined;
    consumedTime: Date | undefined;
    sessionId: string | undefined;
    description: string | undefined;
}

export class PersistedGrantsApiDto implements IPersistedGrantsApiDto {
    totalCount!: number;
    pageSize!: number;
    persistedGrants!: PersistedGrantApiDto[] | undefined;

    constructor(data?: IPersistedGrantsApiDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["persistedGrants"])) {
                this.persistedGrants = [] as any;
                for (let item of _data["persistedGrants"])
                    this.persistedGrants!.push(PersistedGrantApiDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PersistedGrantsApiDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersistedGrantsApiDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.persistedGrants)) {
            data["persistedGrants"] = [];
            for (let item of this.persistedGrants)
                data["persistedGrants"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPersistedGrantsApiDto {
    totalCount: number;
    pageSize: number;
    persistedGrants: PersistedGrantApiDto[] | undefined;
}

export class RoleWithCountDto implements IRoleWithCountDto {
    id!: string | undefined;
    name!: string | undefined;
    normalizedName!: string | undefined;
    description!: string | undefined;
    userCount!: number;

    constructor(data?: IRoleWithCountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            this.userCount = _data["userCount"];
        }
    }

    static fromJS(data: any): RoleWithCountDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleWithCountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        data["userCount"] = this.userCount;
        return data;
    }
}

export interface IRoleWithCountDto {
    id: string | undefined;
    name: string | undefined;
    normalizedName: string | undefined;
    description: string | undefined;
    userCount: number;
}

export class CreateRoleDto implements ICreateRoleDto {
    name!: string;
    description!: string | undefined;

    constructor(data?: ICreateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface ICreateRoleDto {
    name: string;
    description: string | undefined;
}

export class UpdateRoleDto implements IUpdateRoleDto {
    name!: string;
    description!: string | undefined;

    constructor(data?: IUpdateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface IUpdateRoleDto {
    name: string;
    description: string | undefined;
}

export class RoleUserDto implements IRoleUserDto {
    id!: string | undefined;
    userName!: string | undefined;
    email!: string | undefined;
    displayName!: string | undefined;
    isActive!: boolean;
    createdAt!: Date;

    constructor(data?: IRoleUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.displayName = _data["displayName"];
            this.isActive = _data["isActive"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RoleUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["displayName"] = this.displayName;
        data["isActive"] = this.isActive;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IRoleUserDto {
    id: string | undefined;
    userName: string | undefined;
    email: string | undefined;
    displayName: string | undefined;
    isActive: boolean;
    createdAt: Date;
}

export class RoleClaimDto implements IRoleClaimDto {
    roleId!: string | undefined;
    claimType!: string | undefined;
    claimValue!: string | undefined;

    constructor(data?: IRoleClaimDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.claimType = _data["claimType"];
            this.claimValue = _data["claimValue"];
        }
    }

    static fromJS(data: any): RoleClaimDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleClaimDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        return data;
    }
}

export interface IRoleClaimDto {
    roleId: string | undefined;
    claimType: string | undefined;
    claimValue: string | undefined;
}

export class AddRoleClaimDto implements IAddRoleClaimDto {
    claimType!: string;
    claimValue!: string;

    constructor(data?: IAddRoleClaimDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.claimType = _data["claimType"];
            this.claimValue = _data["claimValue"];
        }
    }

    static fromJS(data: any): AddRoleClaimDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddRoleClaimDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        return data;
    }
}

export interface IAddRoleClaimDto {
    claimType: string;
    claimValue: string;
}

export class TokenListResponseOfActiveTokenDto implements ITokenListResponseOfActiveTokenDto {
    items!: ActiveTokenDto[] | undefined;
    totalCount!: number;
    page!: number;
    pageSize!: number;
    totalPages!: number;

    constructor(data?: ITokenListResponseOfActiveTokenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ActiveTokenDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
        }
    }

    static fromJS(data: any): TokenListResponseOfActiveTokenDto {
        data = typeof data === 'object' ? data : {};
        let result = new TokenListResponseOfActiveTokenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        return data;
    }
}

export interface ITokenListResponseOfActiveTokenDto {
    items: ActiveTokenDto[] | undefined;
    totalCount: number;
    page: number;
    pageSize: number;
    totalPages: number;
}

export class ActiveTokenDto implements IActiveTokenDto {
    key!: string | undefined;
    type!: string | undefined;
    subjectId!: string | undefined;
    userName!: string | undefined;
    email!: string | undefined;
    sessionId!: string | undefined;
    clientId!: string | undefined;
    clientName!: string | undefined;
    creationTime!: Date;
    expiration!: Date | undefined;
    remainingSeconds!: number | undefined;
    remainingTimeFormatted!: string | undefined;
    isExpired!: boolean;
    isRevoked!: boolean;
    revokedAt!: Date | undefined;
    scopes!: string | undefined;
    identityProvider!: string | undefined;

    constructor(data?: IActiveTokenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.type = _data["type"];
            this.subjectId = _data["subjectId"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.sessionId = _data["sessionId"];
            this.clientId = _data["clientId"];
            this.clientName = _data["clientName"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.expiration = _data["expiration"] ? new Date(_data["expiration"].toString()) : <any>undefined;
            this.remainingSeconds = _data["remainingSeconds"];
            this.remainingTimeFormatted = _data["remainingTimeFormatted"];
            this.isExpired = _data["isExpired"];
            this.isRevoked = _data["isRevoked"];
            this.revokedAt = _data["revokedAt"] ? new Date(_data["revokedAt"].toString()) : <any>undefined;
            this.scopes = _data["scopes"];
            this.identityProvider = _data["identityProvider"];
        }
    }

    static fromJS(data: any): ActiveTokenDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActiveTokenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["type"] = this.type;
        data["subjectId"] = this.subjectId;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["sessionId"] = this.sessionId;
        data["clientId"] = this.clientId;
        data["clientName"] = this.clientName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["expiration"] = this.expiration ? this.expiration.toISOString() : <any>undefined;
        data["remainingSeconds"] = this.remainingSeconds;
        data["remainingTimeFormatted"] = this.remainingTimeFormatted;
        data["isExpired"] = this.isExpired;
        data["isRevoked"] = this.isRevoked;
        data["revokedAt"] = this.revokedAt ? this.revokedAt.toISOString() : <any>undefined;
        data["scopes"] = this.scopes;
        data["identityProvider"] = this.identityProvider;
        return data;
    }
}

export interface IActiveTokenDto {
    key: string | undefined;
    type: string | undefined;
    subjectId: string | undefined;
    userName: string | undefined;
    email: string | undefined;
    sessionId: string | undefined;
    clientId: string | undefined;
    clientName: string | undefined;
    creationTime: Date;
    expiration: Date | undefined;
    remainingSeconds: number | undefined;
    remainingTimeFormatted: string | undefined;
    isExpired: boolean;
    isRevoked: boolean;
    revokedAt: Date | undefined;
    scopes: string | undefined;
    identityProvider: string | undefined;
}

export class TokenListResponseOfRevokedTokenDto implements ITokenListResponseOfRevokedTokenDto {
    items!: RevokedTokenDto[] | undefined;
    totalCount!: number;
    page!: number;
    pageSize!: number;
    totalPages!: number;

    constructor(data?: ITokenListResponseOfRevokedTokenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RevokedTokenDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
        }
    }

    static fromJS(data: any): TokenListResponseOfRevokedTokenDto {
        data = typeof data === 'object' ? data : {};
        let result = new TokenListResponseOfRevokedTokenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        return data;
    }
}

export interface ITokenListResponseOfRevokedTokenDto {
    items: RevokedTokenDto[] | undefined;
    totalCount: number;
    page: number;
    pageSize: number;
    totalPages: number;
}

export class RevokedTokenDto implements IRevokedTokenDto {
    id!: number;
    jti!: string | undefined;
    subjectId!: string | undefined;
    userName!: string | undefined;
    email!: string | undefined;
    clientId!: string | undefined;
    clientName!: string | undefined;
    tokenType!: string | undefined;
    expirationTime!: Date | undefined;
    revokedAt!: Date;
    reason!: string | undefined;
    revokedBy!: string | undefined;

    constructor(data?: IRevokedTokenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.jti = _data["jti"];
            this.subjectId = _data["subjectId"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.clientId = _data["clientId"];
            this.clientName = _data["clientName"];
            this.tokenType = _data["tokenType"];
            this.expirationTime = _data["expirationTime"] ? new Date(_data["expirationTime"].toString()) : <any>undefined;
            this.revokedAt = _data["revokedAt"] ? new Date(_data["revokedAt"].toString()) : <any>undefined;
            this.reason = _data["reason"];
            this.revokedBy = _data["revokedBy"];
        }
    }

    static fromJS(data: any): RevokedTokenDto {
        data = typeof data === 'object' ? data : {};
        let result = new RevokedTokenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["jti"] = this.jti;
        data["subjectId"] = this.subjectId;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["clientId"] = this.clientId;
        data["clientName"] = this.clientName;
        data["tokenType"] = this.tokenType;
        data["expirationTime"] = this.expirationTime ? this.expirationTime.toISOString() : <any>undefined;
        data["revokedAt"] = this.revokedAt ? this.revokedAt.toISOString() : <any>undefined;
        data["reason"] = this.reason;
        data["revokedBy"] = this.revokedBy;
        return data;
    }
}

export interface IRevokedTokenDto {
    id: number;
    jti: string | undefined;
    subjectId: string | undefined;
    userName: string | undefined;
    email: string | undefined;
    clientId: string | undefined;
    clientName: string | undefined;
    tokenType: string | undefined;
    expirationTime: Date | undefined;
    revokedAt: Date;
    reason: string | undefined;
    revokedBy: string | undefined;
}

export class TokenStatistics implements ITokenStatistics {
    activeTokens!: number;
    revokedTokens!: number;
    expiringSoon!: number;
    expiredTokens!: number;
    activeUsers!: number;
    activeClients!: number;

    constructor(data?: ITokenStatistics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activeTokens = _data["activeTokens"];
            this.revokedTokens = _data["revokedTokens"];
            this.expiringSoon = _data["expiringSoon"];
            this.expiredTokens = _data["expiredTokens"];
            this.activeUsers = _data["activeUsers"];
            this.activeClients = _data["activeClients"];
        }
    }

    static fromJS(data: any): TokenStatistics {
        data = typeof data === 'object' ? data : {};
        let result = new TokenStatistics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activeTokens"] = this.activeTokens;
        data["revokedTokens"] = this.revokedTokens;
        data["expiringSoon"] = this.expiringSoon;
        data["expiredTokens"] = this.expiredTokens;
        data["activeUsers"] = this.activeUsers;
        data["activeClients"] = this.activeClients;
        return data;
    }
}

export interface ITokenStatistics {
    activeTokens: number;
    revokedTokens: number;
    expiringSoon: number;
    expiredTokens: number;
    activeUsers: number;
    activeClients: number;
}

/** Token  */
export class TokenCheckResponse implements ITokenCheckResponse {
    jti!: string | undefined;
    isRevoked!: boolean;

    constructor(data?: ITokenCheckResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jti = _data["jti"];
            this.isRevoked = _data["isRevoked"];
        }
    }

    static fromJS(data: any): TokenCheckResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TokenCheckResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jti"] = this.jti;
        data["isRevoked"] = this.isRevoked;
        return data;
    }
}

/** Token  */
export interface ITokenCheckResponse {
    jti: string | undefined;
    isRevoked: boolean;
}

export class RevokeTokenRequest implements IRevokeTokenRequest {
    jti!: string | undefined;
    subjectId!: string | undefined;
    clientId!: string | undefined;
    tokenType!: string | undefined;
    expirationTime!: Date | undefined;
    reason!: string | undefined;

    constructor(data?: IRevokeTokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jti = _data["jti"];
            this.subjectId = _data["subjectId"];
            this.clientId = _data["clientId"];
            this.tokenType = _data["tokenType"];
            this.expirationTime = _data["expirationTime"] ? new Date(_data["expirationTime"].toString()) : <any>undefined;
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): RevokeTokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RevokeTokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jti"] = this.jti;
        data["subjectId"] = this.subjectId;
        data["clientId"] = this.clientId;
        data["tokenType"] = this.tokenType;
        data["expirationTime"] = this.expirationTime ? this.expirationTime.toISOString() : <any>undefined;
        data["reason"] = this.reason;
        return data;
    }
}

export interface IRevokeTokenRequest {
    jti: string | undefined;
    subjectId: string | undefined;
    clientId: string | undefined;
    tokenType: string | undefined;
    expirationTime: Date | undefined;
    reason: string | undefined;
}

/**  */
export class RevokeAllResponse implements IRevokeAllResponse {
    success!: boolean;
    message!: string | undefined;
    revokedCount!: number;

    constructor(data?: IRevokeAllResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.revokedCount = _data["revokedCount"];
        }
    }

    static fromJS(data: any): RevokeAllResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RevokeAllResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["revokedCount"] = this.revokedCount;
        return data;
    }
}

/**  */
export interface IRevokeAllResponse {
    success: boolean;
    message: string | undefined;
    revokedCount: number;
}

/**  */
export class CleanupResponse implements ICleanupResponse {
    success!: boolean;
    message!: string | undefined;
    cleanedCount!: number;

    constructor(data?: ICleanupResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.cleanedCount = _data["cleanedCount"];
        }
    }

    static fromJS(data: any): CleanupResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CleanupResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["cleanedCount"] = this.cleanedCount;
        return data;
    }
}

/**  */
export interface ICleanupResponse {
    success: boolean;
    message: string | undefined;
    cleanedCount: number;
}

export class PagedUserResultDto implements IPagedUserResultDto {
    items!: UserListItemDto[] | undefined;
    totalCount!: number;
    pageIndex!: number;
    pageSize!: number;
    totalPages!: number;

    constructor(data?: IPagedUserResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserListItemDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
        }
    }

    static fromJS(data: any): PagedUserResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedUserResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        return data;
    }
}

export interface IPagedUserResultDto {
    items: UserListItemDto[] | undefined;
    totalCount: number;
    pageIndex: number;
    pageSize: number;
    totalPages: number;
}

export class UserListItemDto implements IUserListItemDto {
    id!: string | undefined;
    userName!: string | undefined;
    email!: string | undefined;
    displayName!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    isActive!: boolean;
    emailConfirmed!: boolean;
    lockoutEnd!: Date | undefined;
    createdAt!: Date;
    roles!: string[] | undefined;

    constructor(data?: IUserListItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.displayName = _data["displayName"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.isActive = _data["isActive"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>undefined;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): UserListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["displayName"] = this.displayName;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["isActive"] = this.isActive;
        data["emailConfirmed"] = this.emailConfirmed;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface IUserListItemDto {
    id: string | undefined;
    userName: string | undefined;
    email: string | undefined;
    displayName: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    isActive: boolean;
    emailConfirmed: boolean;
    lockoutEnd: Date | undefined;
    createdAt: Date;
    roles: string[] | undefined;
}

export class UserDetailDto implements IUserDetailDto {
    id!: string | undefined;
    userName!: string | undefined;
    email!: string | undefined;
    emailConfirmed!: boolean;
    phoneNumber!: string | undefined;
    phoneNumberConfirmed!: boolean;
    twoFactorEnabled!: boolean;
    lockoutEnabled!: boolean;
    lockoutEnd!: Date | undefined;
    accessFailedCount!: number;
    firstName!: string | undefined;
    lastName!: string | undefined;
    displayName!: string | undefined;
    primaryOrganizationId!: string | undefined;
    primaryOrganizationName!: string | undefined;
    tenantId!: string | undefined;
    isActive!: boolean;
    createdAt!: Date;
    updatedAt!: Date | undefined;
    roles!: string[] | undefined;
    claims!: UserClaimSimpleDto[] | undefined;

    constructor(data?: IUserDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>undefined;
            this.accessFailedCount = _data["accessFailedCount"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.displayName = _data["displayName"];
            this.primaryOrganizationId = _data["primaryOrganizationId"];
            this.primaryOrganizationName = _data["primaryOrganizationName"];
            this.tenantId = _data["tenantId"];
            this.isActive = _data["isActive"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(UserClaimSimpleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["emailConfirmed"] = this.emailConfirmed;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["accessFailedCount"] = this.accessFailedCount;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["displayName"] = this.displayName;
        data["primaryOrganizationId"] = this.primaryOrganizationId;
        data["primaryOrganizationName"] = this.primaryOrganizationName;
        data["tenantId"] = this.tenantId;
        data["isActive"] = this.isActive;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserDetailDto {
    id: string | undefined;
    userName: string | undefined;
    email: string | undefined;
    emailConfirmed: boolean;
    phoneNumber: string | undefined;
    phoneNumberConfirmed: boolean;
    twoFactorEnabled: boolean;
    lockoutEnabled: boolean;
    lockoutEnd: Date | undefined;
    accessFailedCount: number;
    firstName: string | undefined;
    lastName: string | undefined;
    displayName: string | undefined;
    primaryOrganizationId: string | undefined;
    primaryOrganizationName: string | undefined;
    tenantId: string | undefined;
    isActive: boolean;
    createdAt: Date;
    updatedAt: Date | undefined;
    roles: string[] | undefined;
    claims: UserClaimSimpleDto[] | undefined;
}

export class UserClaimSimpleDto implements IUserClaimSimpleDto {
    type!: string | undefined;
    value!: string | undefined;

    constructor(data?: IUserClaimSimpleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UserClaimSimpleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserClaimSimpleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["value"] = this.value;
        return data;
    }
}

export interface IUserClaimSimpleDto {
    type: string | undefined;
    value: string | undefined;
}

export class UpdateUserDetailDto implements IUpdateUserDetailDto {
    userName!: string;
    email!: string;
    firstName!: string | undefined;
    lastName!: string | undefined;
    displayName!: string | undefined;
    phoneNumber!: string | undefined;
    primaryOrganizationId!: string | undefined;
    isActive!: boolean;
    emailConfirmed!: boolean;
    lockoutEnabled!: boolean;
    twoFactorEnabled!: boolean;

    constructor(data?: IUpdateUserDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.displayName = _data["displayName"];
            this.phoneNumber = _data["phoneNumber"];
            this.primaryOrganizationId = _data["primaryOrganizationId"];
            this.isActive = _data["isActive"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
        }
    }

    static fromJS(data: any): UpdateUserDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["displayName"] = this.displayName;
        data["phoneNumber"] = this.phoneNumber;
        data["primaryOrganizationId"] = this.primaryOrganizationId;
        data["isActive"] = this.isActive;
        data["emailConfirmed"] = this.emailConfirmed;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        return data;
    }
}

export interface IUpdateUserDetailDto {
    userName: string;
    email: string;
    firstName: string | undefined;
    lastName: string | undefined;
    displayName: string | undefined;
    phoneNumber: string | undefined;
    primaryOrganizationId: string | undefined;
    isActive: boolean;
    emailConfirmed: boolean;
    lockoutEnabled: boolean;
    twoFactorEnabled: boolean;
}

export class UserClaimDto implements IUserClaimDto {
    id!: number;
    userId!: string | undefined;
    claimType!: string | undefined;
    claimValue!: string | undefined;

    constructor(data?: IUserClaimDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.claimType = _data["claimType"];
            this.claimValue = _data["claimValue"];
        }
    }

    static fromJS(data: any): UserClaimDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserClaimDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        return data;
    }
}

export interface IUserClaimDto {
    id: number;
    userId: string | undefined;
    claimType: string | undefined;
    claimValue: string | undefined;
}

export class AddUserClaimDto implements IAddUserClaimDto {
    claimType!: string;
    claimValue!: string;

    constructor(data?: IAddUserClaimDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.claimType = _data["claimType"];
            this.claimValue = _data["claimValue"];
        }
    }

    static fromJS(data: any): AddUserClaimDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddUserClaimDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        return data;
    }
}

export interface IAddUserClaimDto {
    claimType: string;
    claimValue: string;
}

export class UserStatsDto implements IUserStatsDto {
    totalUsers!: number;
    activeUsers!: number;
    inactiveUsers!: number;
    lockedUsers!: number;
    unconfirmedUsers!: number;
    recentRegistrations!: number;
    roleDistribution!: RoleDistributionDto[] | undefined;

    constructor(data?: IUserStatsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalUsers = _data["totalUsers"];
            this.activeUsers = _data["activeUsers"];
            this.inactiveUsers = _data["inactiveUsers"];
            this.lockedUsers = _data["lockedUsers"];
            this.unconfirmedUsers = _data["unconfirmedUsers"];
            this.recentRegistrations = _data["recentRegistrations"];
            if (Array.isArray(_data["roleDistribution"])) {
                this.roleDistribution = [] as any;
                for (let item of _data["roleDistribution"])
                    this.roleDistribution!.push(RoleDistributionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserStatsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserStatsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalUsers"] = this.totalUsers;
        data["activeUsers"] = this.activeUsers;
        data["inactiveUsers"] = this.inactiveUsers;
        data["lockedUsers"] = this.lockedUsers;
        data["unconfirmedUsers"] = this.unconfirmedUsers;
        data["recentRegistrations"] = this.recentRegistrations;
        if (Array.isArray(this.roleDistribution)) {
            data["roleDistribution"] = [];
            for (let item of this.roleDistribution)
                data["roleDistribution"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserStatsDto {
    totalUsers: number;
    activeUsers: number;
    inactiveUsers: number;
    lockedUsers: number;
    unconfirmedUsers: number;
    recentRegistrations: number;
    roleDistribution: RoleDistributionDto[] | undefined;
}

export class RoleDistributionDto implements IRoleDistributionDto {
    roleId!: string | undefined;
    roleName!: string | undefined;
    userCount!: number;
    percentage!: number;

    constructor(data?: IRoleDistributionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
            this.userCount = _data["userCount"];
            this.percentage = _data["percentage"];
        }
    }

    static fromJS(data: any): RoleDistributionDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDistributionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["userCount"] = this.userCount;
        data["percentage"] = this.percentage;
        return data;
    }
}

export interface IRoleDistributionDto {
    roleId: string | undefined;
    roleName: string | undefined;
    userCount: number;
    percentage: number;
}

export class ResetPasswordDto implements IResetPasswordDto {
    newPassword!: string;
    confirmPassword!: string;

    constructor(data?: IResetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newPassword = _data["newPassword"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newPassword"] = this.newPassword;
        data["confirmPassword"] = this.confirmPassword;
        return data;
    }
}

export interface IResetPasswordDto {
    newPassword: string;
    confirmPassword: string;
}

export class SetUserRolesDto implements ISetUserRolesDto {
    roleIds!: string[] | undefined;

    constructor(data?: ISetUserRolesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["roleIds"])) {
                this.roleIds = [] as any;
                for (let item of _data["roleIds"])
                    this.roleIds!.push(item);
            }
        }
    }

    static fromJS(data: any): SetUserRolesDto {
        data = typeof data === 'object' ? data : {};
        let result = new SetUserRolesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.roleIds)) {
            data["roleIds"] = [];
            for (let item of this.roleIds)
                data["roleIds"].push(item);
        }
        return data;
    }
}

export interface ISetUserRolesDto {
    roleIds: string[] | undefined;
}

export class UserRoleDto implements IUserRoleDto {
    userId!: string | undefined;
    roleId!: string | undefined;
    roleName!: string | undefined;

    constructor(data?: IUserRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
        }
    }

    static fromJS(data: any): UserRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        return data;
    }
}

export interface IUserRoleDto {
    userId: string | undefined;
    roleId: string | undefined;
    roleName: string | undefined;
}

export class AvailabilityDto implements IAvailabilityDto {
    available!: boolean;

    constructor(data?: IAvailabilityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.available = _data["available"];
        }
    }

    static fromJS(data: any): AvailabilityDto {
        data = typeof data === 'object' ? data : {};
        let result = new AvailabilityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["available"] = this.available;
        return data;
    }
}

export interface IAvailabilityDto {
    available: boolean;
}

export class BulkOperationResultDto implements IBulkOperationResultDto {
    success!: boolean;
    processedCount!: number;
    failedCount!: number;
    errors!: string[] | undefined;

    constructor(data?: IBulkOperationResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.processedCount = _data["processedCount"];
            this.failedCount = _data["failedCount"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): BulkOperationResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BulkOperationResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["processedCount"] = this.processedCount;
        data["failedCount"] = this.failedCount;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IBulkOperationResultDto {
    success: boolean;
    processedCount: number;
    failedCount: number;
    errors: string[] | undefined;
}

export class BulkUserOperationDto implements IBulkUserOperationDto {
    userIds!: string[];
    operation!: string;
    roleId!: string | undefined;

    constructor(data?: IBulkUserOperationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.userIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["userIds"])) {
                this.userIds = [] as any;
                for (let item of _data["userIds"])
                    this.userIds!.push(item);
            }
            this.operation = _data["operation"];
            this.roleId = _data["roleId"];
        }
    }

    static fromJS(data: any): BulkUserOperationDto {
        data = typeof data === 'object' ? data : {};
        let result = new BulkUserOperationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        data["operation"] = this.operation;
        data["roleId"] = this.roleId;
        return data;
    }
}

export interface IBulkUserOperationDto {
    userIds: string[];
    operation: string;
    roleId: string | undefined;
}

export class CreateUserDto implements ICreateUserDto {
    userName!: string;
    email!: string;
    password!: string;
    confirmPassword!: string;
    firstName!: string | undefined;
    lastName!: string | undefined;
    displayName!: string | undefined;
    phoneNumber!: string | undefined;
    primaryOrganizationId!: string | undefined;
    tenantId!: string | undefined;
    isActive!: boolean;
    emailConfirmed!: boolean;
    roles!: string[] | undefined;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.displayName = _data["displayName"];
            this.phoneNumber = _data["phoneNumber"];
            this.primaryOrganizationId = _data["primaryOrganizationId"];
            this.tenantId = _data["tenantId"];
            this.isActive = _data["isActive"];
            this.emailConfirmed = _data["emailConfirmed"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["displayName"] = this.displayName;
        data["phoneNumber"] = this.phoneNumber;
        data["primaryOrganizationId"] = this.primaryOrganizationId;
        data["tenantId"] = this.tenantId;
        data["isActive"] = this.isActive;
        data["emailConfirmed"] = this.emailConfirmed;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface ICreateUserDto {
    userName: string;
    email: string;
    password: string;
    confirmPassword: string;
    firstName: string | undefined;
    lastName: string | undefined;
    displayName: string | undefined;
    phoneNumber: string | undefined;
    primaryOrganizationId: string | undefined;
    tenantId: string | undefined;
    isActive: boolean;
    emailConfirmed: boolean;
    roles: string[] | undefined;
}

export class BaseRoleDtoOfString implements IBaseRoleDtoOfString {
    id!: string | undefined;

    constructor(data?: IBaseRoleDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BaseRoleDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new BaseRoleDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IBaseRoleDtoOfString {
    id: string | undefined;
}

export class RoleDtoOfString extends BaseRoleDtoOfString implements IRoleDtoOfString {
    name!: string;

    constructor(data?: IRoleDtoOfString) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RoleDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        super.toJSON(data);
        return data;
    }
}

export interface IRoleDtoOfString extends IBaseRoleDtoOfString {
    name: string;
}

export class IdentityRoleDto extends RoleDtoOfString implements IIdentityRoleDto {

    constructor(data?: IIdentityRoleDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): IdentityRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IIdentityRoleDto extends IRoleDtoOfString {
}

export class RolesDtoOfIdentityRoleDtoAndString implements IRolesDtoOfIdentityRoleDtoAndString {
    pageSize!: number;
    totalCount!: number;
    roles!: IdentityRoleDto[] | undefined;

    constructor(data?: IRolesDtoOfIdentityRoleDtoAndString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(IdentityRoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RolesDtoOfIdentityRoleDtoAndString {
        data = typeof data === 'object' ? data : {};
        let result = new RolesDtoOfIdentityRoleDtoAndString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRolesDtoOfIdentityRoleDtoAndString {
    pageSize: number;
    totalCount: number;
    roles: IdentityRoleDto[] | undefined;
}

export class IdentityRolesDto extends RolesDtoOfIdentityRoleDtoAndString implements IIdentityRolesDto {

    constructor(data?: IIdentityRolesDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): IdentityRolesDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityRolesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IIdentityRolesDto extends IRolesDtoOfIdentityRoleDtoAndString {
}

export class UsersDtoOfIdentityUserDtoAndString implements IUsersDtoOfIdentityUserDtoAndString {
    pageSize!: number;
    totalCount!: number;
    users!: IdentityUserDto[] | undefined;

    constructor(data?: IUsersDtoOfIdentityUserDtoAndString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(IdentityUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UsersDtoOfIdentityUserDtoAndString {
        data = typeof data === 'object' ? data : {};
        let result = new UsersDtoOfIdentityUserDtoAndString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUsersDtoOfIdentityUserDtoAndString {
    pageSize: number;
    totalCount: number;
    users: IdentityUserDto[] | undefined;
}

export class IdentityUsersDto extends UsersDtoOfIdentityUserDtoAndString implements IIdentityUsersDto {

    constructor(data?: IIdentityUsersDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): IdentityUsersDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUsersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IIdentityUsersDto extends IUsersDtoOfIdentityUserDtoAndString {
}

export class BaseUserDtoOfString implements IBaseUserDtoOfString {
    id!: string | undefined;

    constructor(data?: IBaseUserDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BaseUserDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new BaseUserDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IBaseUserDtoOfString {
    id: string | undefined;
}

export class UserDtoOfString extends BaseUserDtoOfString implements IUserDtoOfString {
    userName!: string;
    email!: string;
    emailConfirmed!: boolean;
    phoneNumber!: string | undefined;
    phoneNumberConfirmed!: boolean;
    lockoutEnabled!: boolean;
    twoFactorEnabled!: boolean;
    accessFailedCount!: number;
    lockoutEnd!: Date | undefined;

    constructor(data?: IUserDtoOfString) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.accessFailedCount = _data["accessFailedCount"];
            this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["emailConfirmed"] = this.emailConfirmed;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["accessFailedCount"] = this.accessFailedCount;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IUserDtoOfString extends IBaseUserDtoOfString {
    userName: string;
    email: string;
    emailConfirmed: boolean;
    phoneNumber: string | undefined;
    phoneNumberConfirmed: boolean;
    lockoutEnabled: boolean;
    twoFactorEnabled: boolean;
    accessFailedCount: number;
    lockoutEnd: Date | undefined;
}

export class IdentityUserDto extends UserDtoOfString implements IIdentityUserDto {

    constructor(data?: IIdentityUserDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): IdentityUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IIdentityUserDto extends IUserDtoOfString {
}

export class RoleClaimsApiDtoOfString implements IRoleClaimsApiDtoOfString {
    claims!: RoleClaimApiDtoOfString[] | undefined;
    totalCount!: number;
    pageSize!: number;

    constructor(data?: IRoleClaimsApiDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(RoleClaimApiDtoOfString.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): RoleClaimsApiDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new RoleClaimsApiDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IRoleClaimsApiDtoOfString {
    claims: RoleClaimApiDtoOfString[] | undefined;
    totalCount: number;
    pageSize: number;
}

export class RoleClaimApiDtoOfString implements IRoleClaimApiDtoOfString {
    claimId!: number;
    roleId!: string | undefined;
    claimType!: string;
    claimValue!: string;

    constructor(data?: IRoleClaimApiDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.claimId = _data["claimId"];
            this.roleId = _data["roleId"];
            this.claimType = _data["claimType"];
            this.claimValue = _data["claimValue"];
        }
    }

    static fromJS(data: any): RoleClaimApiDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new RoleClaimApiDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["claimId"] = this.claimId;
        data["roleId"] = this.roleId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        return data;
    }
}

export interface IRoleClaimApiDtoOfString {
    claimId: number;
    roleId: string | undefined;
    claimType: string;
    claimValue: string;
}

export class UserRolesApiDtoOfIdentityRoleDto implements IUserRolesApiDtoOfIdentityRoleDto {
    roles!: IdentityRoleDto[] | undefined;
    pageSize!: number;
    totalCount!: number;

    constructor(data?: IUserRolesApiDtoOfIdentityRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(IdentityRoleDto.fromJS(item));
            }
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): UserRolesApiDtoOfIdentityRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRolesApiDtoOfIdentityRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IUserRolesApiDtoOfIdentityRoleDto {
    roles: IdentityRoleDto[] | undefined;
    pageSize: number;
    totalCount: number;
}

export class UserRoleApiDtoOfString implements IUserRoleApiDtoOfString {
    userId!: string | undefined;
    roleId!: string | undefined;

    constructor(data?: IUserRoleApiDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
        }
    }

    static fromJS(data: any): UserRoleApiDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleApiDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        return data;
    }
}

export interface IUserRoleApiDtoOfString {
    userId: string | undefined;
    roleId: string | undefined;
}

export class UserClaimsApiDtoOfString implements IUserClaimsApiDtoOfString {
    claims!: UserClaimApiDtoOfString[] | undefined;
    totalCount!: number;
    pageSize!: number;

    constructor(data?: IUserClaimsApiDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(UserClaimApiDtoOfString.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): UserClaimsApiDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new UserClaimsApiDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IUserClaimsApiDtoOfString {
    claims: UserClaimApiDtoOfString[] | undefined;
    totalCount: number;
    pageSize: number;
}

export class UserClaimApiDtoOfString implements IUserClaimApiDtoOfString {
    claimId!: number;
    userId!: string | undefined;
    claimType!: string;
    claimValue!: string;

    constructor(data?: IUserClaimApiDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.claimId = _data["claimId"];
            this.userId = _data["userId"];
            this.claimType = _data["claimType"];
            this.claimValue = _data["claimValue"];
        }
    }

    static fromJS(data: any): UserClaimApiDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new UserClaimApiDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["claimId"] = this.claimId;
        data["userId"] = this.userId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        return data;
    }
}

export interface IUserClaimApiDtoOfString {
    claimId: number;
    userId: string | undefined;
    claimType: string;
    claimValue: string;
}

export class UserProvidersApiDtoOfString implements IUserProvidersApiDtoOfString {
    providers!: UserProviderApiDtoOfString[] | undefined;

    constructor(data?: IUserProvidersApiDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["providers"])) {
                this.providers = [] as any;
                for (let item of _data["providers"])
                    this.providers!.push(UserProviderApiDtoOfString.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserProvidersApiDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new UserProvidersApiDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.providers)) {
            data["providers"] = [];
            for (let item of this.providers)
                data["providers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserProvidersApiDtoOfString {
    providers: UserProviderApiDtoOfString[] | undefined;
}

export class UserProviderApiDtoOfString implements IUserProviderApiDtoOfString {
    userId!: string | undefined;
    userName!: string | undefined;
    providerKey!: string | undefined;
    loginProvider!: string | undefined;
    providerDisplayName!: string | undefined;

    constructor(data?: IUserProviderApiDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.providerKey = _data["providerKey"];
            this.loginProvider = _data["loginProvider"];
            this.providerDisplayName = _data["providerDisplayName"];
        }
    }

    static fromJS(data: any): UserProviderApiDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new UserProviderApiDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["providerKey"] = this.providerKey;
        data["loginProvider"] = this.loginProvider;
        data["providerDisplayName"] = this.providerDisplayName;
        return data;
    }
}

export interface IUserProviderApiDtoOfString {
    userId: string | undefined;
    userName: string | undefined;
    providerKey: string | undefined;
    loginProvider: string | undefined;
    providerDisplayName: string | undefined;
}

export class UserProviderDeleteApiDtoOfString implements IUserProviderDeleteApiDtoOfString {
    userId!: string | undefined;
    providerKey!: string | undefined;
    loginProvider!: string | undefined;

    constructor(data?: IUserProviderDeleteApiDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.providerKey = _data["providerKey"];
            this.loginProvider = _data["loginProvider"];
        }
    }

    static fromJS(data: any): UserProviderDeleteApiDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new UserProviderDeleteApiDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["providerKey"] = this.providerKey;
        data["loginProvider"] = this.loginProvider;
        return data;
    }
}

export interface IUserProviderDeleteApiDtoOfString {
    userId: string | undefined;
    providerKey: string | undefined;
    loginProvider: string | undefined;
}

export class UserChangePasswordApiDtoOfString implements IUserChangePasswordApiDtoOfString {
    userId!: string | undefined;
    password!: string;
    confirmPassword!: string;

    constructor(data?: IUserChangePasswordApiDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): UserChangePasswordApiDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new UserChangePasswordApiDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        return data;
    }
}

export interface IUserChangePasswordApiDtoOfString {
    userId: string | undefined;
    password: string;
    confirmPassword: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}